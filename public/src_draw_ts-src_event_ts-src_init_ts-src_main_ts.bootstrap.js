"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwww"] = self["webpackChunkwww"] || []).push([["src_draw_ts-src_event_ts-src_init_ts-src_main_ts"],{

/***/ "./aleo/sdk/src/index.js":
/*!*******************************!*\
  !*** ./aleo/sdk/src/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* reexport safe */ _account__WEBPACK_IMPORTED_MODULE_0__.Account),\n/* harmony export */   Address: () => (/* reexport safe */ _aleohq_wasm__WEBPACK_IMPORTED_MODULE_3__.Address),\n/* harmony export */   AleoNetworkClient: () => (/* reexport safe */ _aleo_network_client__WEBPACK_IMPORTED_MODULE_1__.AleoNetworkClient),\n/* harmony export */   DevelopmentClient: () => (/* reexport safe */ _development_client__WEBPACK_IMPORTED_MODULE_2__.DevelopmentClient),\n/* harmony export */   PrivateKey: () => (/* reexport safe */ _aleohq_wasm__WEBPACK_IMPORTED_MODULE_3__.PrivateKey),\n/* harmony export */   Signature: () => (/* reexport safe */ _aleohq_wasm__WEBPACK_IMPORTED_MODULE_3__.Signature),\n/* harmony export */   ViewKey: () => (/* reexport safe */ _aleohq_wasm__WEBPACK_IMPORTED_MODULE_3__.ViewKey)\n/* harmony export */ });\n/* harmony import */ var _account__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./account */ \"./aleo/sdk/src/account.ts\");\n/* harmony import */ var _aleo_network_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./aleo_network_client */ \"./aleo/sdk/src/aleo_network_client.ts\");\n/* harmony import */ var _development_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./development_client */ \"./aleo/sdk/src/development_client.ts\");\n/* harmony import */ var _aleohq_wasm__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @aleohq/wasm */ \"./aleo/wasm/pkg/aleo_wasm.js\");\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://www/./aleo/sdk/src/index.js?");

/***/ }),

/***/ "./aleo/wasm/pkg/aleo_wasm.js":
/*!************************************!*\
  !*** ./aleo/wasm/pkg/aleo_wasm.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Address: () => (/* binding */ Address),\n/* harmony export */   ExecutionResponse: () => (/* binding */ ExecutionResponse),\n/* harmony export */   FeeExecution: () => (/* binding */ FeeExecution),\n/* harmony export */   PrivateKey: () => (/* binding */ PrivateKey),\n/* harmony export */   PrivateKeyCiphertext: () => (/* binding */ PrivateKeyCiphertext),\n/* harmony export */   Program: () => (/* binding */ Program),\n/* harmony export */   RecordCiphertext: () => (/* binding */ RecordCiphertext),\n/* harmony export */   RecordPlaintext: () => (/* binding */ RecordPlaintext),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   ViewKey: () => (/* binding */ ViewKey),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   initSync: () => (/* binding */ initSync)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\nlet wasm;\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nlet cachedBigInt64Memory0 = null;\n\nfunction getBigInt64Memory0() {\n    if (cachedBigInt64Memory0 === null || cachedBigInt64Memory0.byteLength === 0) {\n        cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);\n    }\n    return cachedBigInt64Memory0;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nclass Address {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Address.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr);\n    }\n    /**\n    * @param {PrivateKey} private_key\n    * @returns {Address}\n    */\n    static from_private_key(private_key) {\n        _assertClass(private_key, PrivateKey);\n        const ret = wasm.address_from_private_key(private_key.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {ViewKey} view_key\n    * @returns {Address}\n    */\n    static from_view_key(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.address_from_view_key(view_key.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {string} address\n    * @returns {Address}\n    */\n    static from_string(address) {\n        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.address_from_string(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_string(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1);\n        }\n    }\n    /**\n    * @param {Uint8Array} message\n    * @param {Signature} signature\n    * @returns {boolean}\n    */\n    verify(message, signature) {\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(signature, Signature);\n        const ret = wasm.address_verify(this.__wbg_ptr, ptr0, len0, signature.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n* Webassembly Representation of an Aleo function execution response\n*\n* This object is returned by the execution of an Aleo function off-chain. It provides methods for\n* retrieving the outputs of the function execution.\n*/\nclass ExecutionResponse {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_executionresponse_free(ptr);\n    }\n    /**\n    * Get the outputs of the executed function\n    * @returns {Array<any>}\n    */\n    getOutputs() {\n        const ret = wasm.executionresponse_getOutputs(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n/**\n* Webassembly Representation of an Aleo function fee execution response\n*\n* This object is returned by the execution of the `fee` function in credits.aleo. If a fee is\n* specified when attempting to create an on-chain program execution transaction, this will be\n* required as part of the transaction. However, it can be executed in parallel to execution of\n* main program in separate web workers prior to creation of the transaction.\n*/\nclass FeeExecution {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_feeexecution_free(ptr);\n    }\n    /**\n    * Get the amount of the fee\n    * @returns {bigint}\n    */\n    fee() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.feeexecution_fee(retptr, this.__wbg_ptr);\n            var r0 = getBigInt64Memory0()[retptr / 8 + 0];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            return BigInt.asUintN(64, r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass PrivateKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PrivateKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekey_free(ptr);\n    }\n    /**\n    * Generate a new private key\n    */\n    constructor() {\n        const ret = wasm.privatekey_new();\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * Get a private key from a series of unchecked bytes\n    * @param {Uint8Array} seed\n    * @returns {PrivateKey}\n    */\n    static from_seed_unchecked(seed) {\n        const ptr0 = passArray8ToWasm0(seed, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_from_seed_unchecked(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * Create a private key from a string representation\n    *\n    * This function will fail if the text is not a valid private key\n    * @param {string} private_key\n    * @returns {PrivateKey}\n    */\n    static from_string(private_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(private_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_from_string(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a string representation of the private key\n    *\n    * This function should be used very carefully as it exposes the private key plaintext\n    * @returns {string}\n    */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_to_string(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1);\n        }\n    }\n    /**\n    * Get the view key corresponding to the private key\n    * @returns {ViewKey}\n    */\n    to_view_key() {\n        const ret = wasm.privatekey_to_view_key(this.__wbg_ptr);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n    * Get the address corresponding to the private key\n    * @returns {Address}\n    */\n    to_address() {\n        const ret = wasm.privatekey_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Sign a message with the private key\n    * @param {Uint8Array} message\n    * @returns {Signature}\n    */\n    sign(message) {\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_sign(this.__wbg_ptr, ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n    * Get a private key ciphertext using a secret.\n    *\n    * The secret is sensitive and will be needed to decrypt the private key later, so it should be stored securely\n    * @param {string} secret\n    * @returns {PrivateKeyCiphertext}\n    */\n    static newEncrypted(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_newEncrypted(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encrypt the private key with a secret.\n    *\n    * The secret is sensitive and will be needed to decrypt the private key later, so it should be stored securely\n    * @param {string} secret\n    * @returns {PrivateKeyCiphertext}\n    */\n    toCiphertext(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_toCiphertext(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get private key from a private key ciphertext using a secret.\n    * @param {PrivateKeyCiphertext} ciphertext\n    * @param {string} secret\n    * @returns {PrivateKey}\n    */\n    static fromPrivateKeyCiphertext(ciphertext, secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(ciphertext, PrivateKeyCiphertext);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_fromPrivateKeyCiphertext(retptr, ciphertext.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Private Key in ciphertext form\n*/\nclass PrivateKeyCiphertext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PrivateKeyCiphertext.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekeyciphertext_free(ptr);\n    }\n    /**\n    * Encrypt a private key using a secret string.\n    *\n    * The secret is sensitive and will be needed to decrypt the private key later, so it should be stored securely.\n    * @param {PrivateKey} private_key\n    * @param {string} secret\n    * @returns {PrivateKeyCiphertext}\n    */\n    static encryptPrivateKey(private_key, secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(private_key, PrivateKey);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekeyciphertext_encryptPrivateKey(retptr, private_key.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decrypts a private ciphertext using a secret string.\n    *\n    * This must be the same secret used to encrypt the private key\n    * @param {string} secret\n    * @returns {PrivateKey}\n    */\n    decryptToPrivateKey(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekeyciphertext_decryptToPrivateKey(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the ciphertext string\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekeyciphertext_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1);\n        }\n    }\n    /**\n    * Creates a PrivateKeyCiphertext from a string\n    * @param {string} ciphertext\n    * @returns {PrivateKeyCiphertext}\n    */\n    static fromString(ciphertext) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekeyciphertext_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Webassembly Representation of an Aleo program\n*\n* This object is required to create an Execution or Deployment transaction. It includes several\n* convenience methods for enumerating available functions and each functions' inputs in a\n* javascript object for usage in creation of web forms for input capture.\n*/\nclass Program {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Program.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_program_free(ptr);\n    }\n    /**\n    * Create a program from a program string\n    * @param {string} program\n    * @returns {Program}\n    */\n    static fromString(program) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Program.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a string representation of the program\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1);\n        }\n    }\n    /**\n    * Get javascript array of functions names in the program\n    * @returns {Array<any>}\n    */\n    getFunctions() {\n        const ret = wasm.program_getFunctions(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Get a javascript object representation of the function inputs and types. This can be used\n    * to generate a webform to capture user inputs for an execution of a function.\n    * @param {string} function_name\n    * @returns {Array<any>}\n    */\n    getFunctionInputs(function_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getFunctionInputs(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a javascript object representation of a program record and its types\n    * @param {string} record_name\n    * @returns {object}\n    */\n    getRecordMembers(record_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getRecordMembers(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a javascript object representation of a program struct and its types\n    * @param {string} struct_name\n    * @returns {Array<any>}\n    */\n    getStructMembers(struct_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(struct_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getStructMembers(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Encrypted Aleo record\n*/\nclass RecordCiphertext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RecordCiphertext.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_recordciphertext_free(ptr);\n    }\n    /**\n    * Return a record ciphertext from a string.\n    * @param {string} record\n    * @returns {RecordCiphertext}\n    */\n    static fromString(record) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.recordciphertext_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Return the record ciphertext string.\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordciphertext_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1);\n        }\n    }\n    /**\n    * Decrypt the record ciphertext into plaintext using the view key.\n    * @param {ViewKey} view_key\n    * @returns {RecordPlaintext}\n    */\n    decrypt(view_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(view_key, ViewKey);\n            wasm.recordciphertext_decrypt(retptr, this.__wbg_ptr, view_key.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordPlaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns `true` if the view key can decrypt the record ciphertext.\n    * @param {ViewKey} view_key\n    * @returns {boolean}\n    */\n    isOwner(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.recordciphertext_isOwner(this.__wbg_ptr, view_key.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n* Aleo record plaintext\n*/\nclass RecordPlaintext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RecordPlaintext.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_recordplaintext_free(ptr);\n    }\n    /**\n    * Return a record plaintext from a string.\n    * @param {string} record\n    * @returns {RecordPlaintext}\n    */\n    static fromString(record) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordPlaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the record plaintext string\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1);\n        }\n    }\n    /**\n    * Returns the amount of microcredits in the record\n    * @returns {bigint}\n    */\n    microcredits() {\n        const ret = wasm.recordplaintext_microcredits(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n    * Attempt to get the serial number of a record to determine whether or not is has been spent\n    * @param {PrivateKey} private_key\n    * @param {string} program_id\n    * @param {string} record_name\n    * @returns {string}\n    */\n    serialNumberString(private_key, program_id, record_name) {\n        let deferred4_0;\n        let deferred4_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(private_key, PrivateKey);\n            const ptr0 = passStringToWasm0(program_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(record_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_serialNumberString(retptr, this.__wbg_ptr, private_key.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr3 = r0;\n            var len3 = r1;\n            if (r3) {\n                ptr3 = 0; len3 = 0;\n                throw takeObject(r2);\n            }\n            deferred4_0 = ptr3;\n            deferred4_1 = len3;\n            return getStringFromWasm0(ptr3, len3);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred4_0, deferred4_1);\n        }\n    }\n}\n/**\n*/\nclass Signature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Signature.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signature_free(ptr);\n    }\n    /**\n    * @param {PrivateKey} private_key\n    * @param {Uint8Array} message\n    * @returns {Signature}\n    */\n    static sign(private_key, message) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signature_sign(private_key.__wbg_ptr, ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n    * @param {Address} address\n    * @param {Uint8Array} message\n    * @returns {boolean}\n    */\n    verify(address, message) {\n        _assertClass(address, Address);\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signature_verify(this.__wbg_ptr, address.__wbg_ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * @param {string} signature\n    * @returns {Signature}\n    */\n    static from_string(signature) {\n        const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signature_from_string(ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signature_to_string(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1);\n        }\n    }\n}\n/**\n* Webassembly Representation of an Aleo transaction\n*\n* This object is created when generating an on-chain function deployment or execution and is the\n* object that should be submitted to the Aleo Network in order to deploy or execute a function.\n*/\nclass Transaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Transaction.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr);\n    }\n    /**\n    * Create a transaction from a string\n    * @param {string} transaction\n    * @returns {Transaction}\n    */\n    static fromString(transaction) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(transaction, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transaction_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the transaction as a string. If you want to submit this transaction to the Aleo Network\n    * this function will create the string that should be submitted in the `POST` data.\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1);\n        }\n    }\n    /**\n    * Get the id of the transaction. This is the merkle root of the transaction's inclusion proof.\n    *\n    * This value can be used to query the status of the transaction on the Aleo Network to see\n    * if it was successful. If successful, the transaction will be included in a block and this\n    * value can be used to lookup the transaction data on-chain.\n    * @returns {string}\n    */\n    transactionId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_transactionId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1);\n        }\n    }\n    /**\n    * Get the type of the transaction (will return \"deploy\" or \"execute\")\n    * @returns {string}\n    */\n    transactionType() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_transactionType(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1);\n        }\n    }\n}\n/**\n*/\nclass ViewKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ViewKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_viewkey_free(ptr);\n    }\n    /**\n    * @param {PrivateKey} private_key\n    * @returns {ViewKey}\n    */\n    static from_private_key(private_key) {\n        _assertClass(private_key, PrivateKey);\n        const ret = wasm.viewkey_from_private_key(private_key.__wbg_ptr);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n    * @param {string} view_key\n    * @returns {ViewKey}\n    */\n    static from_string(view_key) {\n        const ptr0 = passStringToWasm0(view_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.viewkey_from_string(ptr0, len0);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.viewkey_to_string(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1);\n        }\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        const ret = wasm.viewkey_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {string} ciphertext\n    * @returns {string}\n    */\n    decrypt(ciphertext) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.viewkey_decrypt(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1);\n        }\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbg_new_abda76e883ba8a5f = function() {\n        const ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {\n        const ret = getObject(arg1).stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1);\n        }\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_crypto_70a96de3b6b73dac = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg_process_dd1577445152112e = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_58036bec3add9e6f = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_6a9d28205ed5b0d8 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbg_msCrypto_adbc770ec9eca9c7 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_f05d779769764e82 = function() { return handleError(function () {\n        const ret = module.require;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbg_getRandomValues_3774744e221a22ad = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_randomFillSync_e950366c42764a07 = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).randomFillSync(takeObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_newnoargs_c9e6043b8ad84109 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_557a2f2deacc4912 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_2b6fea4ea03b1b95 = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_742dd6eab3e9211e = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_c409e731db53a0e2 = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_b70c095388441f2d = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_1c72617491ed7194 = function() { return handleError(function () {\n        const ret = __webpack_require__.g.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg_newwithlength_cd1db47a173e3944 = function(arg0) {\n        const ret = new Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_b4da98d504ac6091 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_call_587b30eea3e09332 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_buffer_55ba7a6b1b92e2ac = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_88d1d8be5df94b9b = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_09938a7d020f049b = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_3698e3ca519b3c3c = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_newwithlength_89eeca401d8918c2 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_subarray_d82be056deb4ad27 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_07da13cc24b69217 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, maybe_memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedBigInt64Memory0 = null;\n    cachedInt32Memory0 = null;\n    cachedUint8Memory0 = null;\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(input) {\n    if (wasm !== undefined) return wasm;\n\n    if (typeof input === 'undefined') {\n        input = new URL(/* asset import */ __webpack_require__(/*! aleo_wasm_bg.wasm */ \"./aleo/wasm/pkg/aleo_wasm_bg.wasm\"), __webpack_require__.b);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await input, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__wbg_init);\n\n\n//# sourceURL=webpack://www/./aleo/wasm/pkg/aleo_wasm.js?");

/***/ }),

/***/ "./aleo/sdk/src/account.ts":
/*!*********************************!*\
  !*** ./aleo/sdk/src/account.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account)\n/* harmony export */ });\n/* harmony import */ var _aleohq_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aleohq/wasm */ \"./aleo/wasm/pkg/aleo_wasm.js\");\n\n/**\n * Key Management class. Enables the creation of a new Aleo Account, importation of an existing account from\n * an existing private key or seed, and message signing and verification functionality.\n *\n * An Aleo Account is generated from a randomly generated seed (number) from which an account private key, view key,\n * and a public account address are derived. The private key lies at the root of an Aleo account. It is a highly\n * sensitive secret and should be protected as it allows for creation of Aleo Program executions and arbitrary value\n * transfers. The View Key allows for decryption of a user's activity on the blockchain. The Address is the public\n * address to which other users of Aleo can send Aleo credits and other records to. This class should only be used\n * environments where the safety of the underlying key material can be assured.\n *\n * @example\n * // Create a new account\n * let myRandomAccount = new Account();\n *\n * // Create an account from a randomly generated seed\n * let seed = new Uint8Array([94, 91, 52, 251, 240, 230, 226, 35, 117, 253, 224, 210, 175, 13, 205, 120, 155, 214, 7, 169, 66, 62, 206, 50, 188, 40, 29, 122, 40, 250, 54, 18]);\n * let mySeededAccount = new Account({seed: seed});\n *\n * // Create an account from an existing private key\n * let myExistingAccount = new Account({privateKey: 'myExistingPrivateKey'})\n *\n * // Sign a message\n * let hello_world = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n * let signature = myRandomAccount.sign(hello_world)\n *\n * // Verify a signature\n * myRandomAccount.verify(hello_world, signature)\n */\nvar Account = /** @class */ (function () {\n    function Account(params) {\n        if (params === void 0) { params = {}; }\n        try {\n            this._privateKey = this.privateKeyFromParams(params);\n        }\n        catch (e) {\n            console.error(\"Wrong parameter\", e);\n            throw new Error(\"Wrong Parameter\");\n        }\n        this._viewKey = _aleohq_wasm__WEBPACK_IMPORTED_MODULE_0__.ViewKey.from_private_key(this._privateKey);\n        this._address = _aleohq_wasm__WEBPACK_IMPORTED_MODULE_0__.Address.from_private_key(this._privateKey);\n    }\n    /**\n     * Attempts to create an account from a private key ciphertext\n     * @param {PrivateKeyCiphertext | string} ciphertext\n     * @param {string} password\n     * @returns {PrivateKey | Error}\n     *\n     * @example\n     * let ciphertext = PrivateKey.newEncrypted(\"password\");\n     * let account = Account.fromCiphertext(ciphertext, \"password\");\n     */\n    Account.fromCiphertext = function (ciphertext, password) {\n        try {\n            ciphertext = (typeof ciphertext === \"string\") ? _aleohq_wasm__WEBPACK_IMPORTED_MODULE_0__.PrivateKeyCiphertext.fromString(ciphertext) : ciphertext;\n            var _privateKey = _aleohq_wasm__WEBPACK_IMPORTED_MODULE_0__.PrivateKey.fromPrivateKeyCiphertext(ciphertext, password);\n            return new Account({ privateKey: _privateKey.to_string() });\n        }\n        catch (e) {\n            throw new Error(\"Wrong password or invalid ciphertext\");\n        }\n    };\n    Account.prototype.privateKeyFromParams = function (params) {\n        if (params.seed) {\n            return _aleohq_wasm__WEBPACK_IMPORTED_MODULE_0__.PrivateKey.from_seed_unchecked(params.seed);\n        }\n        if (params.privateKey) {\n            return _aleohq_wasm__WEBPACK_IMPORTED_MODULE_0__.PrivateKey.from_string(params.privateKey);\n        }\n        return new _aleohq_wasm__WEBPACK_IMPORTED_MODULE_0__.PrivateKey();\n    };\n    Account.prototype.privateKey = function () {\n        return this._privateKey;\n    };\n    Account.prototype.viewKey = function () {\n        return this._viewKey;\n    };\n    Account.prototype.address = function () {\n        return this._address;\n    };\n    Account.prototype.toString = function () {\n        return this.address().to_string();\n    };\n    /**\n     * Encrypt the account's private key with a password\n     * @param {string} ciphertext\n     * @returns {PrivateKeyCiphertext}\n     *\n     * @example\n     * let account = new Account();\n     * let ciphertext = account.encryptAccount(\"password\");\n     */\n    Account.prototype.encryptAccount = function (password) {\n        return this._privateKey.toCiphertext(password);\n    };\n    /**\n     * Decrypts a Record in ciphertext form into plaintext\n     * @param {string} ciphertext\n     * @returns {Record}\n     *\n     * @example\n     * let account = new Account();\n     * let record = account.decryptRecord(\"record1ciphertext\");\n     */\n    Account.prototype.decryptRecord = function (ciphertext) {\n        return this._viewKey.decrypt(ciphertext);\n    };\n    /**\n     * Decrypts an array of Records in ciphertext form into plaintext\n     * @param {string[]} ciphertexts\n     * @returns {Record[]}\n     *\n     * @example\n     * let account = new Account();\n     * let record = account.decryptRecords([\"record1ciphertext\", \"record2ciphertext\"]);\n     */\n    Account.prototype.decryptRecords = function (ciphertexts) {\n        var _this = this;\n        return ciphertexts.map(function (ciphertext) { return _this._viewKey.decrypt(ciphertext); });\n    };\n    /**\n     * Determines whether the account owns a ciphertext record\n     * @param {RecordCipherText | string} ciphertext\n     * @returns {boolean}\n     *\n     * @example\n     * // Create a connection to the Aleo network and an account\n     * let connection = new NodeConnection(\"vm.aleo.org/api\");\n     * let account = Account.fromCiphertext(\"ciphertext\", \"password\");\n     *\n     * // Get a record from the network\n     * let record = connection.getBlock(1234);\n     * let recordCipherText = record.transactions[0].execution.transitions[0].id;\n     *\n     * // Check if the account owns the record\n     * if account.ownsRecord(recordCipherText) {\n     *     // Then one can do something like:\n     *     // Decrypt the record and check if it's spent\n     *     // Store the record in a local database\n     *     // Etc.\n     * }\n     */\n    Account.prototype.ownsRecordCiphertext = function (ciphertext) {\n        if (typeof ciphertext === 'string') {\n            try {\n                var ciphertextObject = _aleohq_wasm__WEBPACK_IMPORTED_MODULE_0__.RecordCiphertext.fromString(ciphertext);\n                return ciphertextObject.isOwner(this._viewKey);\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        else {\n            return ciphertext.isOwner(this._viewKey);\n        }\n    };\n    /**\n     * Signs a message with the account's private key.\n     * Returns a Signature.\n     *\n     * @param {Uint8Array} message\n     * @returns {Signature}\n     *\n     * @example\n     * let account = new Account();\n     * let message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n     * account.sign(message);\n     */\n    Account.prototype.sign = function (message) {\n        return this._privateKey.sign(message);\n    };\n    /**\n     * Verifies the Signature on a message.\n     *\n     * @param {Uint8Array} message\n     * @param {Signature} signature\n     * @returns {boolean}\n     *\n     * @example\n     * let account = new Account();\n     * let message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n     * let signature = account.sign(message);\n     * account.verify(message, signature);\n     */\n    Account.prototype.verify = function (message, signature) {\n        return this._address.verify(message, signature);\n    };\n    return Account;\n}());\n\n\n\n//# sourceURL=webpack://www/./aleo/sdk/src/account.ts?");

/***/ }),

/***/ "./aleo/sdk/src/aleo_network_client.ts":
/*!*********************************************!*\
  !*** ./aleo/sdk/src/aleo_network_client.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AleoNetworkClient: () => (/* binding */ AleoNetworkClient)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/lib/axios.js\");\n/* harmony import */ var _aleohq_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aleohq/wasm */ \"./aleo/wasm/pkg/aleo_wasm.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n/**\n * Connection management class that encapsulates REST calls to publicly exposed endpoints of Aleo nodes.\n * The methods provided in this class provide information on the Aleo Blockchain\n *\n * @param {string} host\n * @example\n * // Connection to a local node\n * let local_connection = new AleoNetworkClient(\"http://localhost:3030\");\n *\n * // Connection to a public beacon node\n * let public_connection = new AleoNetworkClient(\"https://vm.aleo.org/api\");\n */\nvar AleoNetworkClient = /** @class */ (function () {\n    function AleoNetworkClient(host) {\n        this.host = host + \"/testnet3\";\n    }\n    /**\n     * Set an account\n     *\n     * @param {Account} account\n     * @example\n     * let account = new Account();\n     * connection.setAccount(account);\n     */\n    AleoNetworkClient.prototype.setAccount = function (account) {\n        this.account = account;\n    };\n    /**\n     * Return the Aleo account used in the node connection\n     *\n     * @example\n     * let account = connection.getAccount();\n     */\n    AleoNetworkClient.prototype.getAccount = function () {\n        return this.account;\n    };\n    AleoNetworkClient.prototype.fetchData = function (url) {\n        if (url === void 0) { url = \"/\"; }\n        return __awaiter(this, void 0, void 0, function () {\n            var response, error_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(this.host + url)];\n                    case 1:\n                        response = _a.sent();\n                        return [2 /*return*/, response.data];\n                    case 2:\n                        error_1 = _a.sent();\n                        throw new Error(\"Error fetching data.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the block contents of the block at the specified block height\n     *\n     * @param {number} height\n     * @example\n     * let block = connection.getBlock(1234);\n     */\n    AleoNetworkClient.prototype.getBlock = function (height) {\n        return __awaiter(this, void 0, void 0, function () {\n            var block, error_2;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/block/\" + height)];\n                    case 1:\n                        block = _a.sent();\n                        return [2 /*return*/, block];\n                    case 2:\n                        error_2 = _a.sent();\n                        throw new Error(\"Error fetching block.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns a range of blocks between the specified block heights\n     *\n     * @param {number} start\n     * @param {number} end\n     * @example\n     * let blockRange = connection.getBlockRange(2050, 2100);\n     */\n    AleoNetworkClient.prototype.getBlockRange = function (start, end) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_3, errorMessage;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/blocks?start=\" + start + \"&end=\" + end)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_3 = _a.sent();\n                        errorMessage = \"Error fetching blocks between \" + start + \" and \" + end + \".\";\n                        throw new Error(errorMessage);\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the source code of a program\n     *\n     * @param {string} programId\n     * @example\n     * let program = connection.getProgram(\"foo.aleo\");\n     */\n    AleoNetworkClient.prototype.getProgram = function (programId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/program/\" + programId)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_4 = _a.sent();\n                        throw new Error(\"Error fetching program\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the block contents of the latest block\n     *\n     * @example\n     * let latestHeight = connection.getLatestBlock();\n     */\n    AleoNetworkClient.prototype.getLatestBlock = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_5;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/latest/block\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_5 = _a.sent();\n                        throw new Error(\"Error fetching latest block.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the hash of the last published block\n     *\n     * @example\n     * let latestHash = connection.getLatestHash();\n     */\n    AleoNetworkClient.prototype.getLatestHash = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_6;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/latest/hash\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_6 = _a.sent();\n                        throw new Error(\"Error fetching latest hash.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the latest block height\n     *\n     * @example\n     * let latestHeight = connection.getLatestHeight();\n     */\n    AleoNetworkClient.prototype.getLatestHeight = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_7;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/latest/height\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_7 = _a.sent();\n                        throw new Error(\"Error fetching latest height.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the latest state/merkle root of the Aleo blockchain\n     *\n     * @example\n     * let stateRoot = connection.getStateRoot();\n     */\n    AleoNetworkClient.prototype.getStateRoot = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_8;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/latest/stateRoot\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_8 = _a.sent();\n                        throw new Error(\"Error fetching Aleo state root\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns a transaction by its unique identifier\n     *\n     * @param {string} id\n     * @example\n     * let transaction = connection.getTransaction(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n     */\n    AleoNetworkClient.prototype.getTransaction = function (id) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_9;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/transaction/\" + id)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_9 = _a.sent();\n                        throw new Error(\"Error fetching transaction.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the transactions present at the specified block height\n     *\n     * @param {number} height\n     * @example\n     * let transactions = connection.getTransactions(654);\n     */\n    AleoNetworkClient.prototype.getTransactions = function (height) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_10;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/block/\" + height.toString() + \"/transactions\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_10 = _a.sent();\n                        throw new Error(\"Error fetching transactions.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the transactions in the memory pool.\n     *\n     * @example\n     * let transactions = connection.getTransactionsInMempool();\n     */\n    AleoNetworkClient.prototype.getTransactionsInMempool = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_11;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/memoryPool/transactions\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_11 = _a.sent();\n                        throw new Error(\"Error fetching transactions from mempool.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the transition id by its unique identifier\n     *\n     * @example\n     * let transition = connection.getTransitionId(\"2429232855236830926144356377868449890830704336664550203176918782554219952323field\");\n     */\n    AleoNetworkClient.prototype.getTransitionId = function (transition_id) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_12;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/find/transitionID/\" + transition_id)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_12 = _a.sent();\n                        throw new Error(\"Error fetching transition ID.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Attempts to find unspent records in the Aleo blockchain for a specified private key\n     *\n     * @example\n     * // Find all unspent records\n     * const privateKey = \"[PRIVATE_KEY]\";\n     * let records = connection.findUnspentRecords(0, undefined, privateKey);\n     *\n     * // Find specific amounts\n     * const startHeight = 500000;\n     * const amounts = [600000, 1000000];\n     * let records = connection.findUnspentRecords(startHeight, undefined, privateKey, amounts);\n     *\n     * // Find specific amounts with a maximum number of cumulative microcredits\n     * const maxMicrocredits = 100000;\n     * let records = connection.findUnspentRecords(startHeight, undefined, privateKey, undefined, maxMicrocredits);\n     */\n    AleoNetworkClient.prototype.findUnspentRecords = function (startHeight, endHeight, privateKey, amounts, maxMicrocredits) {\n        return __awaiter(this, void 0, void 0, function () {\n            var records, start, end, resolvedPrivateKey, failures, totalRecordValue, latestHeight, viewKey, blockHeight, error_13, blocks, i, block, transactions, j, confirmedTransaction, transaction, k, transition, l, output, record, recordPlaintext, serialNumber, error_14, amounts_found, m, n, error_15, error_16;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // Ensure start height is not negative\n                        if (startHeight < 0) {\n                            throw new Error(\"Start height must be greater than or equal to 0\");\n                        }\n                        records = new Array();\n                        failures = 0;\n                        totalRecordValue = BigInt(0);\n                        // Ensure a private key is present to find owned records\n                        if (typeof privateKey === \"undefined\") {\n                            if (typeof this.account === \"undefined\") {\n                                throw new Error(\"Private key must be specified in an argument to findOwnedRecords or set in the AleoNetworkClient\");\n                            }\n                            else {\n                                resolvedPrivateKey = this.account._privateKey;\n                            }\n                        }\n                        else {\n                            try {\n                                resolvedPrivateKey = _aleohq_wasm__WEBPACK_IMPORTED_MODULE_1__.PrivateKey.from_string(privateKey);\n                            }\n                            catch (error) {\n                                throw new Error(\"Error parsing private key provided.\");\n                            }\n                        }\n                        viewKey = resolvedPrivateKey.to_view_key();\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.getLatestHeight()];\n                    case 2:\n                        blockHeight = _a.sent();\n                        if (typeof blockHeight === \"number\") {\n                            latestHeight = blockHeight;\n                        }\n                        else {\n                            throw new Error(\"Error fetching latest block height.\");\n                        }\n                        return [3 /*break*/, 4];\n                    case 3:\n                        error_13 = _a.sent();\n                        throw new Error(\"Error fetching latest block height.\");\n                    case 4:\n                        // If no end height is specified or is greater than the latest height, set the end height to the latest height\n                        if (typeof endHeight === \"number\" && endHeight <= latestHeight) {\n                            end = endHeight;\n                        }\n                        else {\n                            end = latestHeight;\n                        }\n                        // If the starting is greater than the ending height, return an error\n                        if (startHeight > end) {\n                            throw new Error(\"Start height must be less than or equal to end height.\");\n                        }\n                        _a.label = 5;\n                    case 5:\n                        if (!(end > startHeight)) return [3 /*break*/, 25];\n                        start = end - 50;\n                        if (start < startHeight) {\n                            start = startHeight;\n                        }\n                        _a.label = 6;\n                    case 6:\n                        _a.trys.push([6, 23, , 24]);\n                        return [4 /*yield*/, this.getBlockRange(start, end)];\n                    case 7:\n                        blocks = _a.sent();\n                        end = start;\n                        if (!!(blocks instanceof Error)) return [3 /*break*/, 22];\n                        i = 0;\n                        _a.label = 8;\n                    case 8:\n                        if (!(i < blocks.length)) return [3 /*break*/, 22];\n                        block = blocks[i];\n                        transactions = block.transactions;\n                        if (!!(typeof transactions === \"undefined\")) return [3 /*break*/, 21];\n                        j = 0;\n                        _a.label = 9;\n                    case 9:\n                        if (!(j < transactions.length)) return [3 /*break*/, 21];\n                        confirmedTransaction = transactions[j];\n                        if (!(confirmedTransaction.type == \"execute\")) return [3 /*break*/, 20];\n                        transaction = confirmedTransaction.transaction;\n                        if (!(transaction.execution && !(typeof transaction.execution.transitions == \"undefined\"))) return [3 /*break*/, 20];\n                        k = 0;\n                        _a.label = 10;\n                    case 10:\n                        if (!(k < transaction.execution.transitions.length)) return [3 /*break*/, 20];\n                        transition = transaction.execution.transitions[k];\n                        // Only search for unspent records in credits.aleo (for now)\n                        if (transition.program !== \"credits.aleo\") {\n                            return [3 /*break*/, 19];\n                        }\n                        if (!!(typeof transition.outputs == \"undefined\")) return [3 /*break*/, 19];\n                        l = 0;\n                        _a.label = 11;\n                    case 11:\n                        if (!(l < transition.outputs.length)) return [3 /*break*/, 19];\n                        output = transition.outputs[l];\n                        if (!(output.type === \"record\")) return [3 /*break*/, 18];\n                        _a.label = 12;\n                    case 12:\n                        _a.trys.push([12, 17, , 18]);\n                        record = _aleohq_wasm__WEBPACK_IMPORTED_MODULE_1__.RecordCiphertext.fromString(output.value);\n                        if (!record.isOwner(viewKey)) return [3 /*break*/, 16];\n                        recordPlaintext = record.decrypt(viewKey);\n                        serialNumber = recordPlaintext.serialNumberString(resolvedPrivateKey, \"credits.aleo\", \"credits\");\n                        _a.label = 13;\n                    case 13:\n                        _a.trys.push([13, 15, , 16]);\n                        return [4 /*yield*/, this.getTransitionId(serialNumber)];\n                    case 14:\n                        _a.sent();\n                        return [3 /*break*/, 16];\n                    case 15:\n                        error_14 = _a.sent();\n                        // If it's not found, add it to the list of unspent records\n                        records.push(recordPlaintext);\n                        // If the user specified a maximum number of microcredits, check if the search has found enough\n                        if (typeof maxMicrocredits === \"number\") {\n                            totalRecordValue = recordPlaintext.microcredits();\n                            // Exit if the search has found the amount specified\n                            if (totalRecordValue >= BigInt(maxMicrocredits)) {\n                                return [2 /*return*/, records];\n                            }\n                        }\n                        // If the user specified a list of amounts, check if the search has found them\n                        if (!(typeof amounts == \"undefined\")) {\n                            amounts_found = 0;\n                            for (m = 0; m < amounts.length; m++) {\n                                for (n = 0; m < records.length; n++) {\n                                    if (records[n].microcredits() >= BigInt(amounts[m])) {\n                                        amounts_found++;\n                                        // Exit if the search has found the amounts specified\n                                        if (amounts_found >= amounts.length) {\n                                            return [2 /*return*/, records];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        return [3 /*break*/, 16];\n                    case 16: return [3 /*break*/, 18];\n                    case 17:\n                        error_15 = _a.sent();\n                        return [3 /*break*/, 18];\n                    case 18:\n                        l++;\n                        return [3 /*break*/, 11];\n                    case 19:\n                        k++;\n                        return [3 /*break*/, 10];\n                    case 20:\n                        j++;\n                        return [3 /*break*/, 9];\n                    case 21:\n                        i++;\n                        return [3 /*break*/, 8];\n                    case 22: return [3 /*break*/, 24];\n                    case 23:\n                        error_16 = _a.sent();\n                        // If there is an error fetching blocks, log it and keep searching\n                        console.log(\"Error fetching blocks in range: \" + start.toString() + \"-\" + end.toString());\n                        console.log(\"Error: \", error_16);\n                        failures += 1;\n                        if (failures > 10) {\n                            console.log(\"10 failures fetching records reached. Returning records fetched so far\");\n                            return [2 /*return*/, records];\n                        }\n                        return [3 /*break*/, 24];\n                    case 24: return [3 /*break*/, 5];\n                    case 25: return [2 /*return*/, records];\n                }\n            });\n        });\n    };\n    return AleoNetworkClient;\n}());\n\n\n\n//# sourceURL=webpack://www/./aleo/sdk/src/aleo_network_client.ts?");

/***/ }),

/***/ "./aleo/sdk/src/development_client.ts":
/*!********************************************!*\
  !*** ./aleo/sdk/src/development_client.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DevelopmentClient: () => (/* binding */ DevelopmentClient),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/lib/axios.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar config = {\n    headers: {\n        \"Content-type\": \"application/json; charset=UTF-8\",\n        \"Referrer-Policy\": \"no-referrer\"\n    },\n};\nvar DevelopmentClient = /** @class */ (function () {\n    /**\n     * Creates a new DevelopmentClient to interact with an Aleo Development Server.\n     *\n     * @param {string} baseURL The URL of the Aleo Development Server\n     */\n    function DevelopmentClient(baseURL) {\n        this.baseURL = baseURL;\n    }\n    DevelopmentClient.prototype.sendRequest = function (path, request) {\n        return __awaiter(this, void 0, void 0, function () {\n            var response;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"\".concat(this.baseURL, \"/testnet3\").concat(path), request, config)];\n                    case 1:\n                        response = _a.sent();\n                        if (!(response.statusText = \"200\")) {\n                            throw new Error(\"Error sending request: \".concat(response.statusText));\n                        }\n                        return [4 /*yield*/, response.data];\n                    case 2: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Deploys a program on the Aleo Network via an Aleo development server.\n     * It requires an Aleo Development Server to be running remotely or locally.\n     * If one is not running, this function will throw an error.\n     *\n     * Information on how to run an Aleo Development Server can be found here:\n     * https://github.com/AleoHQ/aleo/rust/develop/README.md\n     * @param {string} program Text representation of the program to be deployed\n     * @param {number} fee Fee to be paid for the program deployment (REQUIRED)\n     * @param {string | undefined} privateKey Optional private key of the user who is deploying the program\n     * @param {string | undefined} password If the development server is started with an encrypted private key, the password is required\n     * @param {string | undefined} feeRecord Optional record in text format to be used for the fee. If not provided, the server will search the network for a suitable record to pay the fee.\n     * @returns {string | Error} The transaction_id of the deployment transaction if successful\n     *\n     * @example\n     * const Program = 'program yourprogram.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n';\n     * const client = new DevelopmentClient(\"http://0.0.0.0:4040\");\n     * const transaction_id = await client.deployProgram(Program, 6000000, privateKeyString);\n     */\n    DevelopmentClient.prototype.deployProgram = function (program, fee, privateKey, password, feeRecord) {\n        return __awaiter(this, void 0, void 0, function () {\n            var request;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        request = {\n                            program: program,\n                            private_key: privateKey,\n                            password: password,\n                            fee: fee * 1000000,\n                            fee_record: feeRecord,\n                        };\n                        return [4 /*yield*/, this.sendRequest('/deploy', request)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Executes a program on the Aleo Network via an Aleo development server.\n     * It requires an Aleo Development Server to be running remotely or locally.\n     * If one is not running, this function will throw an error.\n     *\n     * Information on how to run an Aleo Development Server can be found here:\n     * https://github.com/AleoHQ/aleo/rust/develop/README.md\n     * @param {string} programId The program_id of the program to be executed (e.g. hello.aleo)\n     * @param {string} programFunction The function to execute within the program (e.g. hello)\n     * @param {number} fee Optional Fee to be paid for the execution transaction, specify 0 for no fee\n     * @param {string[]} inputs Array of inputs to be passed to the program\n     * @param {string | undefined} privateKey Optional private key of the user who is executing the program\n     * @param {string | undefined} password If the development server is started with an encrypted private key, the password is required\n     * @param {string | undefined} feeRecord Optional record in text format to be used for the fee. If not provided, the server will search the network for a suitable record to pay the fee.\n     * @returns {string | Error} The transaction_id of the execution transaction if successful\n     *\n     * @example\n     * const privateKey = \"your private key\";\n     * const client = new DevelopmentClient(\"http://0.0.0.0:4040\");\n     * const transaction_id = await client.executeProgram(\"hello.aleo\", \"hello\", 0, [\"5u32\", \"5u32\"], privateKeyString);\n     */\n    DevelopmentClient.prototype.executeProgram = function (programId, programFunction, fee, inputs, privateKey, password, feeRecord) {\n        return __awaiter(this, void 0, void 0, function () {\n            var request;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        request = {\n                            program_id: programId,\n                            program_function: programFunction,\n                            inputs: inputs,\n                            private_key: privateKey,\n                            password: password,\n                            fee: fee * 1000000,\n                            fee_record: feeRecord\n                        };\n                        return [4 /*yield*/, this.sendRequest('/execute', request)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Sends an amount in credits to a specified recipient on the Aleo Network\n     * via an Aleo development server. It requires an Aleo Development Server\n     * to be running remotely or locally. If one is not running, this function\n     * will throw an error.\n     *\n     * Information on how to run an Aleo Development Server can be found here:\n     * https://github.com/AleoHQ/aleo/rust/develop/README.md\n     * @param {string} amount The amount of credits to be sent (e.g. 1.5)\n     * @param {number} fee Optional Fee to be paid for the transfer, specify 0 for no fee\n     * @param {string} recipient The recipient of the transfer\n     * @param {string | undefined} privateKey Optional private key of the user who is sending the transfer\n     * @param {string | undefined} password If the development server is started with an encrypted private key, the password is required\n     * @param {string | undefined} feeRecord Optional record in text format to be used for the fee. If not provided, the server will search the network for a suitable record to pay the fee.\n     * @param {string | undefined} amountRecord Optional record in text format to be used to fund the transfer. If not provided, the server will search the network for a suitable record to fund the amount.\n     * @returns {string | Error} The transaction_id of the execution transaction if successful\n     *\n     * @example\n     * const privateKey = \"your private key\";\n     * const recipient = \"recipient's address\";\n     * const client = new DevelopmentClient(\"http://0.0.0.0:4040\");\n     * const transaction_id = await client.transfer(1.5, 0, recipient, privateKey);\n     */\n    DevelopmentClient.prototype.transfer = function (amount, fee, recipient, privateKey, password, feeRecord, amountRecord) {\n        return __awaiter(this, void 0, void 0, function () {\n            var request;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        request = {\n                            amount: amount * 1000000,\n                            fee: fee * 1000000,\n                            recipient: recipient,\n                            private_key: privateKey,\n                            password: password,\n                            fee_record: feeRecord,\n                            amount_record: amountRecord\n                        };\n                        return [4 /*yield*/, this.sendRequest('/transfer', request)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    return DevelopmentClient;\n}());\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DevelopmentClient);\n\n\n//# sourceURL=webpack://www/./aleo/sdk/src/development_client.ts?");

/***/ }),

/***/ "./src/board.ts":
/*!**********************!*\
  !*** ./src/board.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Board: () => (/* binding */ Board)\n/* harmony export */ });\n/* harmony import */ var _chess__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chess */ \"./src/chess.ts\");\n/* harmony import */ var _location__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./location */ \"./src/location.ts\");\n\n\nvar Board = /** @class */ (function () {\n    function Board(account) {\n        this.chessList = [];\n        this.locations = [];\n        this.rowCnt = 12;\n        this.columnCnt = 5;\n        this.account = account;\n        for (var y = 0; y < this.rowCnt; y++) {\n            this.setLocationType(y);\n        }\n        // init chess rank\n        this.initChessList();\n        //init edge location\n        this.initLocationEdges();\n    }\n    Board.prototype.initChessList = function () {\n        var _this = this;\n        var chess_array = [0, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11];\n        chess_array.forEach(function (rank) {\n            _this.chessList.push(new _chess__WEBPACK_IMPORTED_MODULE_0__.Chess(rank, \"0\"));\n            _this.chessList.push(new _chess__WEBPACK_IMPORTED_MODULE_0__.Chess(rank, \"1\"));\n        });\n    };\n    Board.prototype.initLocationEdges = function () {\n        var _this = this;\n        for (var x = 0; x < this.columnCnt; x++) {\n            //添加左右相邻位置的location\n            if (x <= 3) {\n                for (var y = 0; y < this.rowCnt; y++) {\n                    this.addEdge(this.getLocationInstance(x, y), this.getLocationInstance(x + 1, y));\n                }\n            }\n            //添加play1上下相邻的location、play2上下相邻的location \n            for (var y = 0; y <= 4; y++) { //cols\n                this.addEdge(this.getLocationInstance(x, y), this.getLocationInstance(x, y + 1));\n            }\n            for (var y = 6; y <= 10; y++) { //cols\n                this.addEdge(this.getLocationInstance(x, y), this.getLocationInstance(x, y + 1));\n            }\n        }\n        //前线周边位置添加\n        this.addEdge(this.getLocationInstance(0, 5), this.getLocationInstance(0, 6));\n        this.addEdge(this.getLocationInstance(2, 5), this.getLocationInstance(2, 6));\n        this.addEdge(this.getLocationInstance(4, 5), this.getLocationInstance(4, 6));\n        //foreach camp\n        this.locations.forEach(function (location) {\n            if (location.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n                _this.addEdge(location, _this.getLocationInstance(location.x - 1, location.y - 1));\n                _this.addEdge(location, _this.getLocationInstance(location.x - 1, location.y + 1));\n                _this.addEdge(location, _this.getLocationInstance(location.x + 1, location.y - 1));\n                _this.addEdge(location, _this.getLocationInstance(location.x + 1, location.y + 1));\n            }\n        });\n    };\n    //关联两个相邻位置\n    Board.prototype.addEdge = function (location1, location2) {\n        location1.addEdge(location2);\n        location2.addEdge(location1);\n    };\n    // After Field Marshal died, the flag will be reveal \n    Board.prototype.RevealFlag = function (address) {\n        this.GetChessList(address, false).forEach(function (chess) {\n            if (chess.rank == _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Flag) {\n                chess.displayed = true;\n            }\n        });\n    };\n    Board.prototype.destroy_chess = function (chess) {\n        if (chess.rank == _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Flag) {\n            GameOver(chess.address);\n        }\n        //RevealFlag when Field Marshal is destroyed\n        if (chess.rank == 0) {\n            this.RevealFlag(chess.address);\n        }\n        chess.chessStatus = _chess__WEBPACK_IMPORTED_MODULE_0__.ChessStatus.Captured;\n    };\n    // Get the location of a chess\n    Board.prototype.GetChessLocation = function (chess) {\n        for (var _i = 0, _a = this.locations; _i < _a.length; _i++) {\n            var location_1 = _a[_i];\n            if (location_1.getChess() == chess) {\n                return location_1;\n            }\n        }\n        console.log(\"error GetChessLocation not find chess:\", chess.rank);\n        return undefined;\n    };\n    // Return a list of chess for that player.\n    // All the chess belongs to the player will be returned,\n    // no matter died or alive.\n    Board.prototype.GetChessList = function (address, OnBoard) {\n        if (OnBoard === void 0) { OnBoard = false; }\n        var chessList = [];\n        for (var _i = 0, _a = this.chessList; _i < _a.length; _i++) {\n            var chess = _a[_i];\n            if (chess.address != address) {\n                continue;\n            }\n            if (OnBoard) {\n                if (chess.chessStatus == _chess__WEBPACK_IMPORTED_MODULE_0__.ChessStatus.OnBoard) {\n                    chessList.push(chess);\n                }\n            }\n            else {\n                chessList.push(chess);\n            }\n        }\n        return chessList;\n    };\n    // Find the location instance with same (x,y)\n    Board.prototype.getLocationInstance = function (x, y) {\n        for (var _i = 0, _a = this.locations; _i < _a.length; _i++) {\n            var location_2 = _a[_i];\n            if (location_2.x == x && location_2.y == y) {\n                return location_2;\n            }\n        }\n        return new _location__WEBPACK_IMPORTED_MODULE_1__.Location(x, y, _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Headquarters, this.isOnRail(x, y));\n    };\n    Board.prototype.getPlayableLocation = function (x, chess, locations) {\n        for (var y = 6; y < this.rowCnt; y++) {\n            var tmp = this.getLocationInstance(x, y);\n            //行营不能放置 \n            if (tmp.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n                continue;\n            }\n            switch (chess.rank) {\n                case 11: //大本营\n                    if (tmp.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Headquarters) {\n                        locations.push(this.getLocationInstance(x, y));\n                    }\n                    break;\n                case 10: //炸弹只能放在次2行\n                    if (y >= 7) {\n                        locations.push(this.getLocationInstance(x, y));\n                    }\n                    break;\n                case 9: //\n                    if (y >= 10) {\n                        locations.push(this.getLocationInstance(x, y));\n                    }\n                    break;\n                default:\n                    locations.push(this.getLocationInstance(x, y));\n                    break;\n            }\n        }\n    };\n    Board.prototype.GetPlaceableLocation = function (oriLocation) {\n        var tmpLoc = [];\n        var chess = oriLocation.getChess();\n        if (!chess) {\n            return tmpLoc;\n        }\n        for (var x = 0; x < this.columnCnt; x++) {\n            this.getPlayableLocation(x, chess, tmpLoc);\n        }\n        return tmpLoc;\n    };\n    Board.prototype.swap = function (oriLocation, targetLocation) {\n        var oriChess = oriLocation.getChess();\n        var targetChess = targetLocation.getChess();\n        if (this.GetPlaceableLocation(oriLocation).indexOf(targetLocation) != -1 &&\n            this.GetPlaceableLocation(targetLocation).indexOf(oriLocation) != -1) {\n            oriLocation.setChess(targetChess);\n            targetLocation.setChess(oriChess);\n            console.log(targetChess, oriChess);\n        }\n    };\n    // List the movable location for a chess on a particular location\n    Board.prototype.GetMovableLocation = function (oriLocation) {\n        var _a;\n        var queue = [];\n        var visited = [];\n        var movable = [];\n        if (((_a = oriLocation.getChess()) === null || _a === void 0 ? void 0 : _a.rank) == 9 || oriLocation.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Headquarters) {\n            return [];\n        }\n        visited.push(oriLocation);\n        oriLocation.edges.forEach(function (location) { return queue.push(location); });\n        while (queue.length > 0) {\n            var targetLocation = queue.shift();\n            visited.push(targetLocation);\n            var _b = is_movable(oriLocation, targetLocation), movable1 = _b[0], movable2 = _b[1];\n            if (movable1) {\n                movable.push(targetLocation);\n            }\n            if (!movable2) {\n                continue;\n            }\n            targetLocation.edges.forEach(function (location) {\n                if (location.isOnRail == true) {\n                    var visited_bool = false;\n                    for (var _i = 0, visited_1 = visited; _i < visited_1.length; _i++) {\n                        var visitedLocation = visited_1[_i];\n                        if (visitedLocation == location) {\n                            visited_bool = true;\n                            break;\n                        }\n                    }\n                    // if visited -> skip\n                    if (!visited_bool && queue.indexOf(location) == -1)\n                        queue.push(location);\n                }\n            });\n        }\n        return movable;\n    };\n    Board.prototype.Move = function (chess, targetLocation) {\n        var oriLocation = this.GetChessLocation(chess);\n        if (oriLocation && this.GetMovableLocation(oriLocation).indexOf(targetLocation) == -1) {\n            //verify the movable positions for the chess on oriLocation\n            //if not movable, return\n            return -1;\n        }\n        //if chess is already on the board\n        if (oriLocation) {\n            oriLocation.removeChess();\n        }\n        //targetLocation is null\n        var targetChess = targetLocation.getChess();\n        if (targetChess == undefined) {\n            targetLocation.setChess(chess);\n            return 0;\n        }\n        // //if target location have enemy chess\n        // let [alive0, alive1] = chess.compareRank(targetChess);\n        // if (!alive0) {\n        //   this.destroy_chess(chess);\n        // }\n        // if (!alive1) {\n        //   this.destroy_chess(targetChess);\n        // }\n        // //chess1 alive and chess2 dead\n        // if (alive0 && !alive1) {\n        //   targetLocation.setChess(chess);\n        // }\n        // //chess1 dead and chess2 alive\n        // if (!alive0 && alive1) {\n        //   targetLocation.setChess(targetChess);\n        // }\n        // //both dead\n        // if (!alive0 && !alive1) {\n        //   oriLocation!.removeChess();\n        //   targetLocation.removeChess();\n        // }\n        return 0;\n    };\n    Board.prototype.isOnRail = function (x, y) {\n        //第一行和最后一行\n        if (y == 0 || y == 11) {\n            return false;\n        }\n        if (y == 1 || y == 5 || y == 6 || y == 10) {\n            return true;\n        }\n        if (y == 2 || y == 3 || y == 4 || y == 7 || y == 8) {\n            if (x == 0 || x == 4) {\n                return true;\n            }\n            return false;\n        }\n        return false;\n    };\n    //设置location type\n    Board.prototype.setLocationType = function (y) {\n        for (var x = 0; x < this.columnCnt; x++) {\n            var locationType = _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.SoldierStation;\n            //第0行1列或者1行4列是大本营的位置 第12行1列或者12行4列也是大本营的位置\n            if ((x == 1 && (y == 0 || y == 11)) || (x == 3 && (y == 0 || y == 11))) {\n                locationType = _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Headquarters;\n            }\n            //行营\n            if (((x == 1 || x == 3) && (y == 2 || y == 4 || y == 7 || y == 9))\n                || (x == 2 && (y == 3 || y == 8))) {\n                locationType = _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp;\n            }\n            this.locations.push(new _location__WEBPACK_IMPORTED_MODULE_1__.Location(x, y, locationType, this.isOnRail(x, y)));\n        }\n    };\n    return Board;\n}());\n\nfunction is_movable(oriLocation, targetLocation) {\n    var enemyChess = -1; //no ches\n    if (targetLocation.getChess() && targetLocation.getChess().address != oriLocation.getChess().address) {\n        enemyChess = 1; //enemy chess\n    }\n    //我方棋子\n    if (targetLocation.getChess() && targetLocation.getChess().address == oriLocation.getChess().address) {\n        enemyChess = 0; //our chess\n    }\n    //for direct linkage 不是在铁路上但是位置相邻\n    if (!oriLocation.isOnRail && oriLocation.edges.indexOf(targetLocation) != -1) {\n        if (enemyChess == 0) {\n            return [false, false];\n        }\n        //目标位置对方棋子，且目标位置类型是行营\n        if (enemyChess == 1 && targetLocation.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n            return [false, false];\n        }\n        return [true, false];\n    }\n    //for rail case 工兵\n    var engineer = false;\n    if (oriLocation.getChess() && oriLocation.getChess().rank == 8) {\n        engineer = true;\n    }\n    //位置相邻\n    if (oriLocation.edges.indexOf(targetLocation) > -1) {\n        if (enemyChess == 0) {\n            return [false, false];\n        }\n        if (enemyChess == 1 && targetLocation.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n            return [false, false];\n        }\n        if (enemyChess == 1 && targetLocation.locationType != _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n            return [true, false];\n        }\n        if (targetLocation.isOnRail == false) {\n            return [true, false];\n        }\n        return [true, true];\n    }\n    if (enemyChess == 0) {\n        return [false, false];\n    }\n    if (enemyChess == 1 && targetLocation.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n        return [false, false];\n    }\n    if (targetLocation.isOnRail == false) {\n        return [false, false];\n    }\n    if (engineer) {\n        if (enemyChess == 1 && targetLocation.locationType != _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n            return [true, false];\n        }\n        return [true, true];\n    }\n    else {\n        if (enemyChess == 1 && targetLocation.locationType != _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp &&\n            (oriLocation.x == targetLocation.x || oriLocation.y == targetLocation.y)) {\n            return [true, false];\n        }\n        if (targetLocation.isOnRail == true && (oriLocation.x == targetLocation.x || oriLocation.y == targetLocation.y)) {\n            return [true, true];\n        }\n        else {\n            return [false, false];\n        }\n    }\n}\nfunction GameOver(address) {\n    alert(\"Player\" + address + \"Won!\");\n}\n\n\n//# sourceURL=webpack://www/./src/board.ts?");

/***/ }),

/***/ "./src/chess.ts":
/*!**********************!*\
  !*** ./src/chess.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chess: () => (/* binding */ Chess),\n/* harmony export */   ChessStatus: () => (/* binding */ ChessStatus),\n/* harmony export */   Rank: () => (/* binding */ Rank),\n/* harmony export */   Rank_zhHK: () => (/* binding */ Rank_zhHK)\n/* harmony export */ });\nvar Rank_zhHK = [\n    \"司令\",\n    \"軍長\",\n    \"師長\",\n    \"旅長\",\n    \"團長\",\n    \"營長\",\n    \"連長\",\n    \"排長\",\n    \"工兵\",\n    \"地雷\",\n    \"炸彈\",\n    \"軍旗\" //11\n];\nvar Rank;\n(function (Rank) {\n    Rank[Rank[\"Field Marshal\"] = 0] = \"Field Marshal\";\n    Rank[Rank[\"General\"] = 1] = \"General\";\n    Rank[Rank[\"Lieutenant General\"] = 2] = \"Lieutenant General\";\n    Rank[Rank[\"Brigadier\"] = 3] = \"Brigadier\";\n    Rank[Rank[\"Colonel\"] = 4] = \"Colonel\";\n    Rank[Rank[\"Major\"] = 5] = \"Major\";\n    Rank[Rank[\"Captain\"] = 6] = \"Captain\";\n    Rank[Rank[\"Platoon Commander\"] = 7] = \"Platoon Commander\";\n    Rank[Rank[\"Engineer\"] = 8] = \"Engineer\";\n    Rank[Rank[\"Landmine\"] = 9] = \"Landmine\";\n    Rank[Rank[\"Grenade\"] = 10] = \"Grenade\";\n    Rank[Rank[\"Flag\"] = 11] = \"Flag\";\n})(Rank || (Rank = {}));\n//棋子状态\nvar ChessStatus;\n(function (ChessStatus) {\n    ChessStatus[ChessStatus[\"OnBoard\"] = 0] = \"OnBoard\";\n    ChessStatus[ChessStatus[\"Captured\"] = 1] = \"Captured\";\n})(ChessStatus || (ChessStatus = {}));\n// Chess object representing a chess instance\nvar Chess = /** @class */ (function () {\n    function Chess(rank, address) {\n        this.rank = rank;\n        this.chessStatus = ChessStatus.OnBoard;\n        this.displayed = false;\n        this.address = address;\n    }\n    return Chess;\n}());\n\n\n\n//# sourceURL=webpack://www/./src/chess.ts?");

/***/ }),

/***/ "./src/draw.ts":
/*!*********************!*\
  !*** ./src/draw.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   draw: () => (/* binding */ draw),\n/* harmony export */   drawChess: () => (/* binding */ drawChess),\n/* harmony export */   draw_array: () => (/* binding */ draw_array),\n/* harmony export */   getDrawPos: () => (/* binding */ getDrawPos),\n/* harmony export */   getDrawPosIndex: () => (/* binding */ getDrawPosIndex),\n/* harmony export */   getRectObj: () => (/* binding */ getRectObj),\n/* harmony export */   initDraw: () => (/* binding */ initDraw),\n/* harmony export */   resetChess: () => (/* binding */ resetChess)\n/* harmony export */ });\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event */ \"./src/event.ts\");\n/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ \"./src/init.ts\");\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main */ \"./src/main.ts\");\n\n\n\nvar draw_array = [];\n//根据xy坐标获取元素\nfunction getDrawPos(x, y) {\n    return _init__WEBPACK_IMPORTED_MODULE_1__.draw_pos[x + y * 5];\n}\n//获取x、y坐标\nfunction getDrawPosIndex(obj) {\n    var index = _init__WEBPACK_IMPORTED_MODULE_1__.draw_pos.indexOf(obj);\n    if (index === -1) {\n        return undefined;\n    }\n    return { x: index % 5, y: Math.floor(index / 5) };\n}\n//给定的坐标 coordinate 来查找 draw_pos 数组中符合条件的矩形对象\nfunction getRectObj(coordinate) {\n    var canvasX = coordinate.x;\n    var canvasY = coordinate.y;\n    var inside;\n    // 遍历draw_pos数组，查找符合条件的元素\n    _init__WEBPACK_IMPORTED_MODULE_1__.draw_pos.forEach(function (i) {\n        if (i.x <= canvasX && canvasX <= i.x + _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH && i.y <= canvasY && canvasY <= i.y + _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT) {\n            inside = i;\n        }\n    });\n    return inside;\n}\nfunction resetChess() {\n    draw_array = [];\n}\nfunction drawChess(txt, x, y, color, txt_visible) {\n    draw_array.push({ txt: txt, x: x, y: y, color: color, txt_visible: txt_visible });\n}\nvar dash_count = 0;\nvar loop_count = 0;\nfunction initDraw() {\n    dash_count = 0;\n    loop_count = 0;\n}\nfunction draw(ctx) {\n    ctx.clearRect(0, 0, _init__WEBPACK_IMPORTED_MODULE_1__.canvas.width, _init__WEBPACK_IMPORTED_MODULE_1__.canvas.height);\n    //rect\n    loop_count++;\n    if (loop_count >= 300) {\n        loop_count = 0;\n    }\n    draw_array.forEach(function (i) {\n        ctx.save();\n        ctx.beginPath();\n        //draw border\n        ctx.lineWidth = 5;\n        ctx.beginPath();\n        if (getDrawPos(i.x, i.y) == _event__WEBPACK_IMPORTED_MODULE_0__.selected_chess) {\n            ctx.strokeStyle = \"orange\";\n            if (_event__WEBPACK_IMPORTED_MODULE_0__.mouse_down == true) {\n                var ori_x = getDrawPos(i.x, i.y).x;\n                var ori_y = getDrawPos(i.x, i.y).y;\n                ori_x = ori_x + (_event__WEBPACK_IMPORTED_MODULE_0__.mouse_current_pos.x - _event__WEBPACK_IMPORTED_MODULE_0__.mouse_start_pos.x);\n                ori_y = ori_y + (_event__WEBPACK_IMPORTED_MODULE_0__.mouse_current_pos.y - _event__WEBPACK_IMPORTED_MODULE_0__.mouse_start_pos.y);\n                ctx.rect(ori_x, ori_y, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT);\n            }\n            else {\n                ctx.rect(getDrawPos(i.x, i.y).x, getDrawPos(i.x, i.y).y, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT);\n            }\n        }\n        else {\n            ctx.setLineDash([]);\n            ctx.strokeStyle = i.color;\n            ctx.rect(getDrawPos(i.x, i.y).x, getDrawPos(i.x, i.y).y, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT);\n        }\n        //rect\n        ctx.fill();\n        ctx.stroke();\n        if (getDrawPos(i.x, i.y) == _event__WEBPACK_IMPORTED_MODULE_0__.selected_chess)\n            ctx.fillStyle = 'lightblue';\n        else\n            ctx.fillStyle = '#fff';\n        ctx.fill();\n        ctx.closePath();\n        ctx.restore();\n    });\n    //dotted\n    ctx.save();\n    ctx.beginPath();\n    //ctx.setLineDash([6,6]);\n    ctx.setLineDash([]);\n    ctx.lineDashOffset = dash_count;\n    _event__WEBPACK_IMPORTED_MODULE_0__.selected_chess_movable.forEach(function (i) {\n        ctx.lineWidth = 5;\n        ctx.strokeStyle = \"rgba(0,200,0,\" + 1 * Math.abs(loop_count - 150) / 150 + \")\";\n        ctx.strokeRect(i.x, i.y, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT);\n    });\n    ctx.stroke();\n    ctx.closePath();\n    ctx.restore();\n    //text\n    ctx.font = '20px arial';\n    ctx.fillStyle = 'blue';\n    ctx.textAlign = \"left\";\n    draw_array.forEach(function (i) {\n        var debugCheckbox = document.getElementById(\"debug\");\n        if (!debugCheckbox.checked && !i.txt_visible) {\n            return;\n        }\n        if (getDrawPos(i.x, i.y) == _event__WEBPACK_IMPORTED_MODULE_0__.selected_chess && _event__WEBPACK_IMPORTED_MODULE_0__.mouse_down) {\n            var ori_x = getDrawPos(i.x, i.y).x;\n            var ori_y = getDrawPos(i.x, i.y).y;\n            ori_x = ori_x + (_event__WEBPACK_IMPORTED_MODULE_0__.mouse_current_pos.x - _event__WEBPACK_IMPORTED_MODULE_0__.mouse_start_pos.x);\n            ori_y = ori_y + (_event__WEBPACK_IMPORTED_MODULE_0__.mouse_current_pos.y - _event__WEBPACK_IMPORTED_MODULE_0__.mouse_start_pos.y);\n            ctx.rect(ori_x, ori_y, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT);\n            ctx.fillText(i.txt, ori_x + 9, ori_y + 25);\n        }\n        else {\n            ctx.fillText(i.txt, getDrawPos(i.x, i.y).x + 9, getDrawPos(i.x, i.y).y + 25);\n        }\n    });\n}\n\n\n//# sourceURL=webpack://www/./src/draw.ts?");

/***/ }),

/***/ "./src/event.ts":
/*!**********************!*\
  !*** ./src/event.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canvasDown: () => (/* binding */ canvasDown),\n/* harmony export */   canvasMousemove: () => (/* binding */ canvasMousemove),\n/* harmony export */   canvasUp: () => (/* binding */ canvasUp),\n/* harmony export */   current_game_player: () => (/* binding */ current_game_player),\n/* harmony export */   initEventsValue: () => (/* binding */ initEventsValue),\n/* harmony export */   mouse_current_pos: () => (/* binding */ mouse_current_pos),\n/* harmony export */   mouse_down: () => (/* binding */ mouse_down),\n/* harmony export */   mouse_start_pos: () => (/* binding */ mouse_start_pos),\n/* harmony export */   selected_chess: () => (/* binding */ selected_chess),\n/* harmony export */   selected_chess_movable: () => (/* binding */ selected_chess_movable),\n/* harmony export */   setCurrentGamePlayer: () => (/* binding */ setCurrentGamePlayer)\n/* harmony export */ });\n/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw */ \"./src/draw.ts\");\n/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ \"./src/init.ts\");\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main */ \"./src/main.ts\");\n\n\n\nvar mouse_down = false;\nvar mouse_start_pos;\nvar mouse_current_pos;\nvar selected_chess; // draw_pos\nvar selected_chess_movable = [];\nvar current_game_player = 0;\nfunction initEventsValue() {\n    mouse_down = false;\n    mouse_start_pos = undefined;\n    mouse_current_pos = undefined;\n    selected_chess = undefined;\n    selected_chess_movable = [];\n    current_game_player = 0;\n}\n//鼠标点击事件\nfunction canvasDown(e) {\n    mouse_down = true;\n    mouse_start_pos = { x: e.offsetX, y: e.offsetY };\n    mouse_current_pos = { x: e.offsetX, y: e.offsetY };\n    var coords = (0,_draw__WEBPACK_IMPORTED_MODULE_0__.getRectObj)(mouse_start_pos);\n    if (!coords) {\n        console.log(\"coords is undefined\", coords);\n        return;\n    }\n    var logic_coords = (0,_draw__WEBPACK_IMPORTED_MODULE_0__.getDrawPosIndex)(coords);\n    if (!logic_coords) {\n        return;\n    }\n    var chess = _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(logic_coords.x, logic_coords.y).getChess();\n    if (!chess) {\n        return;\n    }\n    if (chess.player != _init__WEBPACK_IMPORTED_MODULE_1__.current_player || current_game_player != _init__WEBPACK_IMPORTED_MODULE_1__.current_player) {\n        console.log(\"player is not right chessPlay:\", chess.player, \"currentGamePlay:\", current_game_player, \"curPlayer:\", _init__WEBPACK_IMPORTED_MODULE_1__.current_player);\n        return;\n    }\n    selected_chess = coords;\n    selected_chess_movable = [];\n    var curLocation = _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(logic_coords.x, logic_coords.y);\n    if (_main__WEBPACK_IMPORTED_MODULE_2__.game_started == true) {\n        var movable_location = _main__WEBPACK_IMPORTED_MODULE_2__.board.GetMovableLocation(curLocation);\n        movable_location.forEach(function (i) { return selected_chess_movable.push((0,_draw__WEBPACK_IMPORTED_MODULE_0__.getDrawPos)(i.x, i.y)); });\n    }\n    else {\n        var movable_location = _main__WEBPACK_IMPORTED_MODULE_2__.board.GetPlaceableLocation(curLocation);\n        console.log('canvas_down game is not start', movable_location);\n        for (var _i = 0, movable_location_1 = movable_location; _i < movable_location_1.length; _i++) {\n            var location_1 = movable_location_1[_i];\n            if (_main__WEBPACK_IMPORTED_MODULE_2__.board.GetPlaceableLocation(location_1).indexOf(curLocation) > -1) {\n                selected_chess_movable.push((0,_draw__WEBPACK_IMPORTED_MODULE_0__.getDrawPos)(location_1.x, location_1.y));\n            }\n        }\n    }\n}\nfunction setCurrentGamePlayer(value) {\n    current_game_player = value;\n}\n//鼠标up事件\nfunction canvasUp(e) {\n    mouse_start_pos = null;\n    mouse_current_pos = null;\n    mouse_down = false;\n    mouse_current_pos = { x: e.offsetX, y: e.offsetY };\n    var rect_obj = (0,_draw__WEBPACK_IMPORTED_MODULE_0__.getRectObj)(mouse_current_pos);\n    if (rect_obj && selected_chess) {\n        //获取原来的坐标和目的坐标\n        var oriPos = (0,_draw__WEBPACK_IMPORTED_MODULE_0__.getDrawPosIndex)(selected_chess);\n        var targetPos = (0,_draw__WEBPACK_IMPORTED_MODULE_0__.getDrawPosIndex)(rect_obj);\n        var oriLocation = _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(oriPos.x, oriPos.y);\n        var chess = oriLocation.getChess();\n        if (chess.player != _init__WEBPACK_IMPORTED_MODULE_1__.current_player) {\n            return;\n        }\n        var targetLocation = _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(targetPos.x, targetPos.y);\n        if (_main__WEBPACK_IMPORTED_MODULE_2__.game_started == false) {\n            _main__WEBPACK_IMPORTED_MODULE_2__.board.swap(oriLocation, targetLocation);\n            (0,_main__WEBPACK_IMPORTED_MODULE_2__.updateDrawArray)();\n            return;\n        }\n        if (_main__WEBPACK_IMPORTED_MODULE_2__.board.Move(chess, targetLocation) != -1) {\n            (0,_main__WEBPACK_IMPORTED_MODULE_2__.timerNextPlayer)();\n            setCurrentGamePlayer(1 - _init__WEBPACK_IMPORTED_MODULE_1__.current_player);\n            setTimeout(_main__WEBPACK_IMPORTED_MODULE_2__.AI_Move, Math.floor((Math.random() * 2000) + 1000));\n        }\n        selected_chess = null;\n        selected_chess_movable = [];\n    }\n    (0,_main__WEBPACK_IMPORTED_MODULE_2__.updateDrawArray)();\n}\nfunction canvasMousemove(e) {\n    if (mouse_down) {\n        mouse_current_pos = { x: e.offsetX, y: e.offsetY };\n    }\n}\n\n\n//# sourceURL=webpack://www/./src/event.ts?");

/***/ }),

/***/ "./src/init.ts":
/*!*********************!*\
  !*** ./src/init.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   all_init: () => (/* binding */ all_init),\n/* harmony export */   canvas: () => (/* binding */ canvas),\n/* harmony export */   ctx: () => (/* binding */ ctx),\n/* harmony export */   current_player: () => (/* binding */ current_player),\n/* harmony export */   default_position: () => (/* binding */ default_position),\n/* harmony export */   draw_pos: () => (/* binding */ draw_pos),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   isChessVisible: () => (/* binding */ isChessVisible)\n/* harmony export */ });\n/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw */ \"./src/draw.ts\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event */ \"./src/event.ts\");\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main */ \"./src/main.ts\");\n\n\n\nvar draw_pos = [];\nvar current_player = 0;\nfunction init() {\n    var x_arr = [7, 370];\n    draw_pos = [];\n    current_player = 0;\n    x_arr.forEach(function (offset) {\n        for (var i = 0; i < 6; i++) {\n            draw_pos.push({ x: 7, y: offset });\n            draw_pos.push({ x: 102, y: offset });\n            draw_pos.push({ x: 204, y: offset });\n            draw_pos.push({ x: 307, y: offset });\n            draw_pos.push({ x: 400, y: offset });\n            offset += 48;\n        }\n    });\n    var startButton = document.getElementById(\"start_button\");\n    startButton.addEventListener(\"click\", _main__WEBPACK_IMPORTED_MODULE_2__.GameStart);\n    var stopButton = document.getElementById(\"stop_button\");\n    stopButton.addEventListener(\"click\", _main__WEBPACK_IMPORTED_MODULE_2__.GameStop);\n    setInterval(_main__WEBPACK_IMPORTED_MODULE_2__.myTimer, 1000);\n}\nfunction default_position(set) {\n    if (set == 1) {\n        var p1 = _main__WEBPACK_IMPORTED_MODULE_2__.board.GetChessList(0, false);\n        //1\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 6).setChess(p1[0]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(1, 6).setChess(p1[1]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 6).setChess(p1[2]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(3, 6).setChess(p1[3]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 6).setChess(p1[4]);\n        //2\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 7).setChess(p1[5]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 7).setChess(p1[6]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 7).setChess(p1[7]);\n        //3\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 8).setChess(p1[8]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(1, 8).setChess(p1[9]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(3, 8).setChess(p1[10]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 8).setChess(p1[11]);\n        //4\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 9).setChess(p1[12]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 9).setChess(p1[13]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 9).setChess(p1[14]);\n        //5\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 10).setChess(p1[15]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(1, 10).setChess(p1[16]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 10).setChess(p1[17]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(3, 10).setChess(p1[18]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 10).setChess(p1[19]);\n        //6\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 11).setChess(p1[20]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(1, 11).setChess(p1[21]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 11).setChess(p1[22]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(3, 11).setChess(p1[24]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 11).setChess(p1[23]);\n        p1 = _main__WEBPACK_IMPORTED_MODULE_2__.board.GetChessList(1);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 5).setChess(p1[0]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(1, 5).setChess(p1[1]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 5).setChess(p1[2]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(3, 5).setChess(p1[3]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 5).setChess(p1[4]);\n        //2\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 4).setChess(p1[5]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 4).setChess(p1[6]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 4).setChess(p1[7]);\n        //3\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 3).setChess(p1[8]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(1, 3).setChess(p1[9]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(3, 3).setChess(p1[10]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 3).setChess(p1[11]);\n        //4\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 2).setChess(p1[12]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 2).setChess(p1[13]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 2).setChess(p1[14]);\n        //5\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 1).setChess(p1[15]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(1, 1).setChess(p1[16]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 1).setChess(p1[17]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(3, 1).setChess(p1[18]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 1).setChess(p1[19]);\n        //6\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 0).setChess(p1[20]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(1, 0).setChess(p1[21]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 0).setChess(p1[22]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(3, 0).setChess(p1[24]);\n        _main__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 0).setChess(p1[23]);\n    }\n}\nvar canvas;\nvar ctx;\nfunction all_init() {\n    (0,_draw__WEBPACK_IMPORTED_MODULE_0__.resetChess)();\n    init();\n    (0,_draw__WEBPACK_IMPORTED_MODULE_0__.initDraw)();\n    (0,_event__WEBPACK_IMPORTED_MODULE_1__.initEventsValue)();\n    (0,_main__WEBPACK_IMPORTED_MODULE_2__.resetBoard)();\n    canvas = document.getElementById(\"Board\");\n    ctx = canvas.getContext(\"2d\");\n    default_position(1);\n    canvas.addEventListener('mousedown', _event__WEBPACK_IMPORTED_MODULE_1__.canvasDown);\n    canvas.addEventListener('mouseup', _event__WEBPACK_IMPORTED_MODULE_1__.canvasUp);\n    canvas.addEventListener('mouseleave', _event__WEBPACK_IMPORTED_MODULE_1__.canvasUp);\n    canvas.addEventListener('mousemove', _event__WEBPACK_IMPORTED_MODULE_1__.canvasMousemove);\n    setInterval(function () { (0,_draw__WEBPACK_IMPORTED_MODULE_0__.draw)(ctx); });\n    (0,_main__WEBPACK_IMPORTED_MODULE_2__.updateDrawArray)();\n    (0,_draw__WEBPACK_IMPORTED_MODULE_0__.draw)(ctx);\n}\nfunction isChessVisible(chess) {\n    if (chess.displayed == true)\n        return true;\n    if (chess.player == current_player)\n        return true;\n    else\n        return false;\n}\n\n\n//# sourceURL=webpack://www/./src/init.ts?");

/***/ }),

/***/ "./src/location.ts":
/*!*************************!*\
  !*** ./src/location.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   LocationType: () => (/* binding */ LocationType),\n/* harmony export */   LocationType_ZN: () => (/* binding */ LocationType_ZN)\n/* harmony export */ });\nvar LocationType_ZN;\n(function (LocationType_ZN) {\n    LocationType_ZN[\"SoldierStation\"] = \"\\u5175\\u8425\";\n    LocationType_ZN[\"Camp\"] = \"\\u884C\\u8425\";\n    LocationType_ZN[\"Headquarters\"] = \"\\u5927\\u672C\\u8425\";\n})(LocationType_ZN || (LocationType_ZN = {}));\n;\nvar LocationType;\n(function (LocationType) {\n    LocationType[\"SoldierStation\"] = \"Soldier Station\";\n    LocationType[\"Camp\"] = \"Camp\";\n    LocationType[\"Headquarters\"] = \"Headquarters\";\n})(LocationType || (LocationType = {}));\n// Represent a movable location on the board\nvar Location = /** @class */ (function () {\n    function Location(x, y, locationType, isOnRail) {\n        this.edges = [];\n        this.isOnRail = false;\n        this.locationType = LocationType.SoldierStation;\n        this.x = x;\n        this.y = y;\n        this.isOnRail = isOnRail;\n        this.locationType = locationType;\n    }\n    // edge is the connection between the locations\n    Location.prototype.addEdge = function (linkedLocation) {\n        if (this.edges.indexOf(linkedLocation) == -1) {\n            this.edges.push(linkedLocation);\n        }\n    };\n    Location.prototype.setChess = function (chess) {\n        this.chess = chess;\n    };\n    Location.prototype.removeChess = function () {\n        this.chess = undefined;\n    };\n    Location.prototype.getChess = function () {\n        return this.chess;\n    };\n    return Location;\n}());\n\n\n\n//# sourceURL=webpack://www/./src/location.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AI_Move: () => (/* binding */ AI_Move),\n/* harmony export */   CHESS_HEIGHT: () => (/* binding */ CHESS_HEIGHT),\n/* harmony export */   CHESS_WIDTH: () => (/* binding */ CHESS_WIDTH),\n/* harmony export */   GameStart: () => (/* binding */ GameStart),\n/* harmony export */   GameStop: () => (/* binding */ GameStop),\n/* harmony export */   board: () => (/* binding */ board),\n/* harmony export */   chess_changed: () => (/* binding */ chess_changed),\n/* harmony export */   game_started: () => (/* binding */ game_started),\n/* harmony export */   myTimer: () => (/* binding */ myTimer),\n/* harmony export */   player_color: () => (/* binding */ player_color),\n/* harmony export */   resetBoard: () => (/* binding */ resetBoard),\n/* harmony export */   timerNextPlayer: () => (/* binding */ timerNextPlayer),\n/* harmony export */   timer_value: () => (/* binding */ timer_value),\n/* harmony export */   updateDrawArray: () => (/* binding */ updateDrawArray)\n/* harmony export */ });\n/* harmony import */ var _aleohq_wasm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @aleohq/wasm */ \"./aleo/wasm/pkg/aleo_wasm.js\");\n/* harmony import */ var _board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./board */ \"./src/board.ts\");\n/* harmony import */ var _chess__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chess */ \"./src/chess.ts\");\n/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./draw */ \"./src/draw.ts\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./event */ \"./src/event.ts\");\n/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./init */ \"./src/init.ts\");\n/* harmony import */ var _aleohq_sdk__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @aleohq/sdk */ \"./aleo/sdk/src/index.js\");\n\n\n\n\n\n\n\n(0,_aleohq_wasm__WEBPACK_IMPORTED_MODULE_6__[\"default\"])().then(function (wasm) {\n    console.log(\"wasm is ....\");\n    var acctount = new _aleohq_sdk__WEBPACK_IMPORTED_MODULE_5__.Account({ privateKey: \"APrivateKey1zkp6FJo46GTFmCTX3yqVS7raJQSLztGd6sC585tLqDqzqBN\" });\n    console.log('acctount:', acctount.toString());\n    var record = _aleohq_wasm__WEBPACK_IMPORTED_MODULE_6__.RecordCiphertext.fromString('record1qyqsprsrxps7kltcp9wdjlhm0dxxejt8a5lelfdk76h4sg3l300wlrcwqyxx66trwfhkxun9v35hguerqqpqzqyl396kvfrcvhdq566gg6gxcjcs8xs8d2uuher4mugnf3lqhzqkp5jp8g9ldz2hu45um65h82w3uazj5s3wajy9nxqeva353da4c58qsz9f3as');\n    console.log('RecordCiphertext:', JSON.stringify(record));\n});\nvar CHESS_WIDTH = 60;\nvar CHESS_HEIGHT = 33;\nvar player_color = [\"blue\", \"read\"];\n//timer\nvar timer_value = 0;\nvar game_started = false;\nvar chess_changed = true;\nfunction myTimer() {\n    if (game_started) {\n        var timerElement = document.getElementById(\"timer\");\n        var i = parseInt(timerElement.value);\n        if (i > 0) {\n            timerElement.value = (i - 1).toString();\n        }\n        else {\n            alert(\"Time's up!\");\n            game_started = false;\n        }\n    }\n}\nfunction timerNextPlayer() {\n    var timerElement = document.getElementById(\"timer\");\n    timerElement.value = timer_value.toString();\n}\nfunction GameStart() {\n    var timerElement = document.getElementById(\"timer\");\n    timer_value = parseInt(timerElement.value);\n    timerElement.disabled = true;\n    var startButton = document.getElementById(\"start_button\");\n    startButton.style.visibility = \"hidden\";\n    var stopButton = document.getElementById(\"stop_button\");\n    stopButton.style.visibility = \"visible\";\n    game_started = true;\n}\nfunction GameStop() {\n    var timerElement = document.getElementById(\"timer\");\n    timerElement.disabled = false;\n    var startButton = document.getElementById(\"start_button\");\n    startButton.style.visibility = \"visible\";\n    var stopButton = document.getElementById(\"stop_button\");\n    stopButton.style.visibility = \"hidden\";\n    game_started = false;\n}\nfunction AI_Move() {\n    var rand_pos;\n    do {\n        console.log(\"Current player\", _init__WEBPACK_IMPORTED_MODULE_4__.current_player);\n        var myArray = board.GetChessList(1 - _init__WEBPACK_IMPORTED_MODULE_4__.current_player, true);\n        var rand = Math.floor(Math.random() * myArray.length);\n        var rand_chess = myArray[rand];\n        console.log(\"randChess:\", rand_chess.rank);\n        var myArray2 = board.GetMovableLocation(board.GetChessLocation(rand_chess));\n        console.log(\"AI_Move moveable array lenght:\", myArray2.length);\n        if (myArray2.length == 0) {\n            continue;\n        }\n        var rand = Math.floor(Math.random() * myArray2.length);\n        rand_pos = myArray2[rand];\n    } while (board.Move(rand_chess, rand_pos) == -1);\n    (0,_event__WEBPACK_IMPORTED_MODULE_3__.setCurrentGamePlayer)(_init__WEBPACK_IMPORTED_MODULE_4__.current_player);\n    timerNextPlayer();\n    updateDrawArray();\n}\nfunction isChessVisible(chess) {\n    if (chess.displayed == true) {\n        return true;\n    }\n    if (chess.player == _init__WEBPACK_IMPORTED_MODULE_4__.current_player) {\n        return true;\n    }\n    return false;\n}\nfunction updateDrawArray() {\n    (0,_draw__WEBPACK_IMPORTED_MODULE_2__.resetChess)();\n    board.locations.forEach(function (i) {\n        var chess = i.getChess();\n        if (chess && chess != null && chess.chessStatus == _chess__WEBPACK_IMPORTED_MODULE_1__.ChessStatus.OnBoard) {\n            var visible = isChessVisible(chess);\n            (0,_draw__WEBPACK_IMPORTED_MODULE_2__.drawChess)(_chess__WEBPACK_IMPORTED_MODULE_1__.Rank_zhHK[chess.rank], i.x, i.y, player_color[chess.player], visible);\n        }\n    });\n}\nfunction resetBoard() {\n    board = new _board__WEBPACK_IMPORTED_MODULE_0__.Board(0);\n}\nvar board;\n(0,_init__WEBPACK_IMPORTED_MODULE_4__.all_init)();\n// testAsm()\n// async function testAsm(){\n//     // 加载 WebAssembly 模块\n//   const wasmModule = await WebAssembly.instantiateStreaming(fetch('rust_hello.wasm'));\n//   // 获取 WebAssembly 函数\n//   const add_Value = wasmModule.instance.exports.add_Value as (a: number, b: number) => number;\n//   // 调用 WebAssembly 函数\n//   const result = add_Value(2, 3);\n//   console.log(result); // 输出 5\n// }\n\n\n//# sourceURL=webpack://www/./src/main.ts?");

/***/ }),

/***/ "./aleo/wasm/pkg/aleo_wasm_bg.wasm":
/*!*****************************************!*\
  !*** ./aleo/wasm/pkg/aleo_wasm_bg.wasm ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"e6d5ae8b9a7e3fa37456.wasm\";\n\n//# sourceURL=webpack://www/./aleo/wasm/pkg/aleo_wasm_bg.wasm?");

/***/ })

}]);
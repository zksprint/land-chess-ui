"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwww"] = self["webpackChunkwww"] || []).push([["src_login_ts"],{

/***/ "./aleo/sdk/src/index.js":
/*!*******************************!*\
  !*** ./aleo/sdk/src/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* reexport safe */ _account__WEBPACK_IMPORTED_MODULE_0__.Account),\n/* harmony export */   Address: () => (/* reexport safe */ _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_3__.Address),\n/* harmony export */   AleoNetworkClient: () => (/* reexport safe */ _aleo_network_client__WEBPACK_IMPORTED_MODULE_1__.AleoNetworkClient),\n/* harmony export */   DevelopmentClient: () => (/* reexport safe */ _development_client__WEBPACK_IMPORTED_MODULE_2__.DevelopmentClient),\n/* harmony export */   PrivateKey: () => (/* reexport safe */ _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_3__.PrivateKey),\n/* harmony export */   Signature: () => (/* reexport safe */ _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_3__.Signature),\n/* harmony export */   ViewKey: () => (/* reexport safe */ _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_3__.ViewKey)\n/* harmony export */ });\n/* harmony import */ var _account__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./account */ \"./aleo/sdk/src/account.ts\");\n/* harmony import */ var _aleo_network_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./aleo_network_client */ \"./aleo/sdk/src/aleo_network_client.ts\");\n/* harmony import */ var _development_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./development_client */ \"./aleo/sdk/src/development_client.ts\");\n/* harmony import */ var _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @aleohq/nodejs */ \"./aleo/wasm/pkg/aleo_wasm.js\");\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://www/./aleo/sdk/src/index.js?");

/***/ }),

/***/ "./aleo/wasm/pkg/aleo_wasm.js":
/*!************************************!*\
  !*** ./aleo/wasm/pkg/aleo_wasm.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Address: () => (/* binding */ Address),\n/* harmony export */   ExecutionResponse: () => (/* binding */ ExecutionResponse),\n/* harmony export */   KeyPair: () => (/* binding */ KeyPair),\n/* harmony export */   PrivateKey: () => (/* binding */ PrivateKey),\n/* harmony export */   PrivateKeyCiphertext: () => (/* binding */ PrivateKeyCiphertext),\n/* harmony export */   Program: () => (/* binding */ Program),\n/* harmony export */   ProgramManager: () => (/* binding */ ProgramManager),\n/* harmony export */   ProvingKey: () => (/* binding */ ProvingKey),\n/* harmony export */   RecordCiphertext: () => (/* binding */ RecordCiphertext),\n/* harmony export */   RecordPlaintext: () => (/* binding */ RecordPlaintext),\n/* harmony export */   Signature: () => (/* binding */ Signature),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   VerifyingKey: () => (/* binding */ VerifyingKey),\n/* harmony export */   ViewKey: () => (/* binding */ ViewKey),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   initSync: () => (/* binding */ initSync)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\nlet wasm;\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_26(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h4a0b59a43c8cf05c(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nfunction passArray8ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 1, 1) >>> 0;\n    getUint8Memory0().set(arg, ptr / 1);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction getArrayU8FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\nfunction __wbg_adapter_188(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__h8a79014dee79eaf9(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n*/\nclass Address {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Address.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_address_free(ptr);\n    }\n    /**\n    * @param {PrivateKey} private_key\n    * @returns {Address}\n    */\n    static from_private_key(private_key) {\n        _assertClass(private_key, PrivateKey);\n        const ret = wasm.address_from_private_key(private_key.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {ViewKey} view_key\n    * @returns {Address}\n    */\n    static from_view_key(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.address_from_view_key(view_key.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {string} address\n    * @returns {Address}\n    */\n    static from_string(address) {\n        const ptr0 = passStringToWasm0(address, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.address_from_string(ptr0, len0);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.address_to_string(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @param {Uint8Array} message\n    * @param {Signature} signature\n    * @returns {boolean}\n    */\n    verify(message, signature) {\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(signature, Signature);\n        const ret = wasm.address_verify(this.__wbg_ptr, ptr0, len0, signature.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n* Webassembly Representation of an Aleo function execution response\n*\n* This object is returned by the execution of an Aleo function off-chain. It provides methods for\n* retrieving the outputs of the function execution.\n*/\nclass ExecutionResponse {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ExecutionResponse.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_executionresponse_free(ptr);\n    }\n    /**\n    * Get the outputs of the executed function\n    * @returns {Array<any>}\n    */\n    getOutputs() {\n        const ret = wasm.executionresponse_getOutputs(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nclass KeyPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(KeyPair.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_keypair_free(ptr);\n    }\n    /**\n    * Create new key pair from proving and verifying keys\n    * @param {ProvingKey} proving_key\n    * @param {VerifyingKey} verifying_key\n    */\n    constructor(proving_key, verifying_key) {\n        _assertClass(proving_key, ProvingKey);\n        var ptr0 = proving_key.__destroy_into_raw();\n        _assertClass(verifying_key, VerifyingKey);\n        var ptr1 = verifying_key.__destroy_into_raw();\n        const ret = wasm.keypair_new(ptr0, ptr1);\n        return KeyPair.__wrap(ret);\n    }\n    /**\n    * Get the proving key\n    * @returns {ProvingKey}\n    */\n    provingKey() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.keypair_provingKey(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the verifying key\n    * @returns {VerifyingKey}\n    */\n    verifyingKey() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.keypair_verifyingKey(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VerifyingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass PrivateKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PrivateKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekey_free(ptr);\n    }\n    /**\n    * Generate a new private key\n    */\n    constructor() {\n        const ret = wasm.privatekey_new();\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * Get a private key from a series of unchecked bytes\n    * @param {Uint8Array} seed\n    * @returns {PrivateKey}\n    */\n    static from_seed_unchecked(seed) {\n        const ptr0 = passArray8ToWasm0(seed, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_from_seed_unchecked(ptr0, len0);\n        return PrivateKey.__wrap(ret);\n    }\n    /**\n    * Create a private key from a string representation\n    *\n    * This function will fail if the text is not a valid private key\n    * @param {string} private_key\n    * @returns {PrivateKey}\n    */\n    static from_string(private_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(private_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_from_string(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a string representation of the private key\n    *\n    * This function should be used very carefully as it exposes the private key plaintext\n    * @returns {string}\n    */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekey_to_string(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Get the view key corresponding to the private key\n    * @returns {ViewKey}\n    */\n    to_view_key() {\n        const ret = wasm.privatekey_to_view_key(this.__wbg_ptr);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n    * Get the address corresponding to the private key\n    * @returns {Address}\n    */\n    to_address() {\n        const ret = wasm.privatekey_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * Sign a message with the private key\n    * @param {Uint8Array} message\n    * @returns {Signature}\n    */\n    sign(message) {\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.privatekey_sign(this.__wbg_ptr, ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n    * Get a private key ciphertext using a secret.\n    *\n    * The secret is sensitive and will be needed to decrypt the private key later, so it should be stored securely\n    * @param {string} secret\n    * @returns {PrivateKeyCiphertext}\n    */\n    static newEncrypted(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_newEncrypted(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Encrypt the private key with a secret.\n    *\n    * The secret is sensitive and will be needed to decrypt the private key later, so it should be stored securely\n    * @param {string} secret\n    * @returns {PrivateKeyCiphertext}\n    */\n    toCiphertext(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_toCiphertext(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get private key from a private key ciphertext using a secret.\n    * @param {PrivateKeyCiphertext} ciphertext\n    * @param {string} secret\n    * @returns {PrivateKey}\n    */\n    static fromPrivateKeyCiphertext(ciphertext, secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(ciphertext, PrivateKeyCiphertext);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekey_fromPrivateKeyCiphertext(retptr, ciphertext.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Private Key in ciphertext form\n*/\nclass PrivateKeyCiphertext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(PrivateKeyCiphertext.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_privatekeyciphertext_free(ptr);\n    }\n    /**\n    * Encrypt a private key using a secret string.\n    *\n    * The secret is sensitive and will be needed to decrypt the private key later, so it should be stored securely.\n    * @param {PrivateKey} private_key\n    * @param {string} secret\n    * @returns {PrivateKeyCiphertext}\n    */\n    static encryptPrivateKey(private_key, secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(private_key, PrivateKey);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekeyciphertext_encryptPrivateKey(retptr, private_key.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Decrypts a private ciphertext using a secret string.\n    *\n    * This must be the same secret used to encrypt the private key\n    * @param {string} secret\n    * @returns {PrivateKey}\n    */\n    decryptToPrivateKey(secret) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(secret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekeyciphertext_decryptToPrivateKey(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the ciphertext string\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.privatekeyciphertext_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Creates a PrivateKeyCiphertext from a string\n    * @param {string} ciphertext\n    * @returns {PrivateKeyCiphertext}\n    */\n    static fromString(ciphertext) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.privatekeyciphertext_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return PrivateKeyCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Webassembly Representation of an Aleo program\n*\n* This object is required to create an Execution or Deployment transaction. It includes several\n* convenience methods for enumerating available functions and each functions' inputs in a\n* javascript object for usage in creation of web forms for input capture.\n*/\nclass Program {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Program.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_program_free(ptr);\n    }\n    /**\n    * Create a program from a program string\n    * @param {string} program\n    * @returns {Program}\n    */\n    static fromString(program) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Program.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a string representation of the program\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Get javascript array of functions names in the program\n    * @returns {Array<any>}\n    */\n    getFunctions() {\n        const ret = wasm.program_getFunctions(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * Get a javascript object representation of the function inputs and types. This can be used\n    * to generate a webform to capture user inputs for an execution of a function.\n    * @param {string} function_name\n    * @returns {Array<any>}\n    */\n    getFunctionInputs(function_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(function_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getFunctionInputs(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a javascript object representation of a program record and its types\n    * @param {string} record_name\n    * @returns {object}\n    */\n    getRecordMembers(record_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getRecordMembers(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get a javascript object representation of a program struct and its types\n    * @param {string} struct_name\n    * @returns {Array<any>}\n    */\n    getStructMembers(struct_name) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(struct_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.program_getStructMembers(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return takeObject(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the credits.aleo program\n    * @returns {Program}\n    */\n    static getCreditsProgram() {\n        const ret = wasm.program_getCreditsProgram();\n        return Program.__wrap(ret);\n    }\n    /**\n    * Get the id of the program\n    * @returns {string}\n    */\n    id() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.program_id(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Determine equality with another program\n    * @param {Program} other\n    * @returns {boolean}\n    */\n    isEqual(other) {\n        _assertClass(other, Program);\n        const ret = wasm.program_isEqual(this.__wbg_ptr, other.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nclass ProgramManager {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ProgramManager.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_programmanager_free(ptr);\n    }\n    /**\n    * Execute an arbitrary function locally\n    *\n    * @param private_key The private key of the sender\n    * @param program The source code of the program being executed\n    * @param function The name of the function to execute\n    * @param inputs A javascript array of inputs to the function\n    * @param amount_record The record to fund the amount from\n    * @param fee_credits The amount of credits to pay as a fee\n    * @param fee_record The record to spend the fee from\n    * @param url The url of the Aleo network node to send the transaction to\n    * @param cache Cache the proving and verifying keys in the ProgramManager's memory.\n    * If this is set to 'true' the keys synthesized (or passed in as optional parameters via the\n    * `proving_key` and `verifying_key` arguments) will be stored in the ProgramManager's memory\n    * and used for subsequent transactions. If this is set to 'false' the proving and verifying\n    * keys will be deallocated from memory after the transaction is executed.\n    * @param proving_key (optional) Provide a verifying key to use for the function execution\n    * @param verifying_key (optional) Provide a verifying key to use for the function execution\n    * @param {PrivateKey} private_key\n    * @param {string} program\n    * @param {string} _function\n    * @param {Array<any>} inputs\n    * @param {boolean} cache\n    * @param {ProvingKey | undefined} proving_key\n    * @param {VerifyingKey | undefined} verifying_key\n    * @returns {ExecutionResponse}\n    */\n    execute_local(private_key, program, _function, inputs, cache, proving_key, verifying_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(private_key, PrivateKey);\n            var ptr0 = private_key.__destroy_into_raw();\n            const ptr1 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            const ptr2 = passStringToWasm0(_function, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len2 = WASM_VECTOR_LEN;\n            let ptr3 = 0;\n            if (!isLikeNone(proving_key)) {\n                _assertClass(proving_key, ProvingKey);\n                ptr3 = proving_key.__destroy_into_raw();\n            }\n            let ptr4 = 0;\n            if (!isLikeNone(verifying_key)) {\n                _assertClass(verifying_key, VerifyingKey);\n                ptr4 = verifying_key.__destroy_into_raw();\n            }\n            wasm.programmanager_execute_local(retptr, this.__wbg_ptr, ptr0, ptr1, len1, ptr2, len2, addHeapObject(inputs), cache, ptr3, ptr4);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ExecutionResponse.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Execute Aleo function and create an Aleo execution transaction\n    *\n    * @param private_key The private key of the sender\n    * @param program The source code of the program being executed\n    * @param function The name of the function to execute\n    * @param inputs A javascript array of inputs to the function\n    * @param fee_credits The amount of credits to pay as a fee\n    * @param fee_record The record to spend the fee from\n    * @param url The url of the Aleo network node to send the transaction to\n    * @param cache Cache the proving and verifying keys in the ProgramManager's memory.\n    * If this is set to 'true' the keys synthesized (or passed in as optional parameters via the\n    * `proving_key` and `verifying_key` arguments) will be stored in the ProgramManager's memory\n    * and used for subsequent transactions. If this is set to 'false' the proving and verifying\n    * keys will be deallocated from memory after the transaction is executed.\n    * @param proving_key (optional) Provide a verifying key to use for the function execution\n    * @param verifying_key (optional) Provide a verifying key to use for the function execution\n    * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n    * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n    * @param {PrivateKey} private_key\n    * @param {string} program\n    * @param {string} _function\n    * @param {Array<any>} inputs\n    * @param {number} fee_credits\n    * @param {RecordPlaintext} fee_record\n    * @param {string} url\n    * @param {boolean} cache\n    * @param {ProvingKey | undefined} proving_key\n    * @param {VerifyingKey | undefined} verifying_key\n    * @param {ProvingKey | undefined} fee_proving_key\n    * @param {VerifyingKey | undefined} fee_verifying_key\n    * @returns {Promise<Transaction>}\n    */\n    execute(private_key, program, _function, inputs, fee_credits, fee_record, url, cache, proving_key, verifying_key, fee_proving_key, fee_verifying_key) {\n        _assertClass(private_key, PrivateKey);\n        var ptr0 = private_key.__destroy_into_raw();\n        const ptr1 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(_function, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        _assertClass(fee_record, RecordPlaintext);\n        var ptr3 = fee_record.__destroy_into_raw();\n        const ptr4 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len4 = WASM_VECTOR_LEN;\n        let ptr5 = 0;\n        if (!isLikeNone(proving_key)) {\n            _assertClass(proving_key, ProvingKey);\n            ptr5 = proving_key.__destroy_into_raw();\n        }\n        let ptr6 = 0;\n        if (!isLikeNone(verifying_key)) {\n            _assertClass(verifying_key, VerifyingKey);\n            ptr6 = verifying_key.__destroy_into_raw();\n        }\n        let ptr7 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr7 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr8 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr8 = fee_verifying_key.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_execute(this.__wbg_ptr, ptr0, ptr1, len1, ptr2, len2, addHeapObject(inputs), fee_credits, ptr3, ptr4, len4, cache, ptr5, ptr6, ptr7, ptr8);\n        return takeObject(ret);\n    }\n    /**\n    * Join two records together to create a new record with an amount of credits equal to the sum\n    * of the credits of the two original records\n    *\n    * @param private_key The private key of the sender\n    * @param record_1 The first record to combine\n    * @param record_2 The second record to combine\n    * @param fee_credits The amount of credits to pay as a fee\n    * @param fee_record The record to spend the fee from\n    * @param url The url of the Aleo network node to send the transaction to\n    * @param cache Cache the proving and verifying keys in the ProgramManager memory. If this is\n    * set to `true` the keys synthesized (or passed in as optional parameters via the\n    * `join_proving_key` and `join_verifying_key` arguments) will be stored in the\n    * ProgramManager's memory and used for subsequent transactions. If this is set to `false` the\n    * proving and verifying keys will be deallocated from memory after the transaction is executed\n    * @param join_proving_key (optional) Provide a proving key to use for the join function\n    * @param join_verifying_key (optional) Provide a verifying key to use for the join function\n    * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n    * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n    * @param {PrivateKey} private_key\n    * @param {RecordPlaintext} record_1\n    * @param {RecordPlaintext} record_2\n    * @param {number} fee_credits\n    * @param {RecordPlaintext} fee_record\n    * @param {string} url\n    * @param {boolean} cache\n    * @param {ProvingKey | undefined} join_proving_key\n    * @param {VerifyingKey | undefined} join_verifying_key\n    * @param {ProvingKey | undefined} fee_proving_key\n    * @param {VerifyingKey | undefined} fee_verifying_key\n    * @returns {Promise<Transaction>}\n    */\n    join(private_key, record_1, record_2, fee_credits, fee_record, url, cache, join_proving_key, join_verifying_key, fee_proving_key, fee_verifying_key) {\n        _assertClass(private_key, PrivateKey);\n        var ptr0 = private_key.__destroy_into_raw();\n        _assertClass(record_1, RecordPlaintext);\n        var ptr1 = record_1.__destroy_into_raw();\n        _assertClass(record_2, RecordPlaintext);\n        var ptr2 = record_2.__destroy_into_raw();\n        _assertClass(fee_record, RecordPlaintext);\n        var ptr3 = fee_record.__destroy_into_raw();\n        const ptr4 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len4 = WASM_VECTOR_LEN;\n        let ptr5 = 0;\n        if (!isLikeNone(join_proving_key)) {\n            _assertClass(join_proving_key, ProvingKey);\n            ptr5 = join_proving_key.__destroy_into_raw();\n        }\n        let ptr6 = 0;\n        if (!isLikeNone(join_verifying_key)) {\n            _assertClass(join_verifying_key, VerifyingKey);\n            ptr6 = join_verifying_key.__destroy_into_raw();\n        }\n        let ptr7 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr7 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr8 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr8 = fee_verifying_key.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_join(this.__wbg_ptr, ptr0, ptr1, ptr2, fee_credits, ptr3, ptr4, len4, cache, ptr5, ptr6, ptr7, ptr8);\n        return takeObject(ret);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.programmanager_new();\n        return ProgramManager.__wrap(ret);\n    }\n    /**\n    * Cache the proving and verifying keys for a program function in WASM memory. This method\n    * will take a verifying and proving key and store them in the program manager's internal\n    * in-memory cache. This memory is allocated in WebAssembly, so it is important to be mindful\n    * of the amount of memory being used. This method will return an error if the keys are already\n    * cached in memory.\n    *\n    * @param program_id The name of the program containing the desired function\n    * @param function The name of the function to store the keys for\n    * @param proving_key The proving key of the function\n    * @param verifying_key The verifying key of the function\n    * @param {string} program\n    * @param {string} _function\n    * @param {ProvingKey} proving_key\n    * @param {VerifyingKey} verifying_key\n    */\n    cacheKeypairInWasmMemory(program, _function, proving_key, verifying_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            _assertClass(proving_key, ProvingKey);\n            var ptr2 = proving_key.__destroy_into_raw();\n            _assertClass(verifying_key, VerifyingKey);\n            var ptr3 = verifying_key.__destroy_into_raw();\n            wasm.programmanager_cacheKeypairInWasmMemory(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, ptr3);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            if (r1) {\n                throw takeObject(r0);\n            }\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the proving & verifying keys cached in WASM memory for a specific function\n    *\n    * @param program_id The name of the program containing the desired function\n    * @param function_id The name of the function to retrieve the keys for\n    * @param {string} program_id\n    * @param {string} _function\n    * @returns {KeyPair}\n    */\n    getCachedKeypair(program_id, _function) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.programmanager_getCachedKeypair(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return KeyPair.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Synthesize a proving and verifying key for a program function. This method should be used\n    * when there is a need to pre-synthesize keys (i.e. for caching purposes, etc.)\n    *\n    * @param program The source code of the program containing the desired function\n    * @param function The name of the function to synthesize the key for\n    * @param {string} program\n    * @param {string} _function\n    * @returns {KeyPair}\n    */\n    synthesizeKeypair(program, _function) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(_function, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.programmanager_synthesizeKeypair(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return KeyPair.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Clear key cache in wasm memory.\n    *\n    * This method will clear the key cache in wasm memory. It is important to note that this will\n    * not DE-allocate the memory assigned to wasm as wasm memory cannot be shrunk. The total\n    * memory allocated to wasm will remain constant but will be available for other usage after\n    * calling this method.\n    */\n    clearKeyCache() {\n        wasm.programmanager_clearKeyCache(this.__wbg_ptr);\n    }\n    /**\n    * Check if the cache contains a keypair for a specific function\n    *\n    * @param program_id The name of the program containing the desired function\n    * @param function_id The name of the function to retrieve the keys for\n    * @param {string} program_id\n    * @param {string} function_id\n    * @returns {boolean}\n    */\n    keyExists(program_id, function_id) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(program_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(function_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.programmanager_keyExists(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return r0 !== 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Deploy an Aleo program\n    *\n    * @param private_key The private key of the sender\n    * @param program The source code of the program being deployed\n    * @param imports A javascript object holding the source code of any imported programs in the\n    * form {\"program_name1\": \"program_source_code\", \"program_name2\": \"program_source_code\", ..}.\n    * Note that all imported programs must be deployed on chain before the main program in order\n    * for the deployment to succeed\n    * @param fee_credits The amount of credits to pay as a fee\n    * @param fee_record The record to spend the fee from\n    * @param url The url of the Aleo network node to send the transaction to\n    * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n    * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n    * @param {PrivateKey} private_key\n    * @param {string} program\n    * @param {object | undefined} imports\n    * @param {number} fee_credits\n    * @param {RecordPlaintext} fee_record\n    * @param {string} url\n    * @param {boolean} cache\n    * @param {ProvingKey | undefined} fee_proving_key\n    * @param {VerifyingKey | undefined} fee_verifying_key\n    * @returns {Promise<Transaction>}\n    */\n    deploy(private_key, program, imports, fee_credits, fee_record, url, cache, fee_proving_key, fee_verifying_key) {\n        _assertClass(private_key, PrivateKey);\n        var ptr0 = private_key.__destroy_into_raw();\n        const ptr1 = passStringToWasm0(program, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        _assertClass(fee_record, RecordPlaintext);\n        var ptr2 = fee_record.__destroy_into_raw();\n        const ptr3 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len3 = WASM_VECTOR_LEN;\n        let ptr4 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr4 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr5 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr5 = fee_verifying_key.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_deploy(this.__wbg_ptr, ptr0, ptr1, len1, isLikeNone(imports) ? 0 : addHeapObject(imports), fee_credits, ptr2, ptr3, len3, cache, ptr4, ptr5);\n        return takeObject(ret);\n    }\n    /**\n    * Split an Aleo credits record into two separate records. This function does not require a fee.\n    *\n    * @param private_key The private key of the sender\n    * @param split_amount The amount of the credit split. This amount will be subtracted from the\n    * value of the record and two new records will be created with the split amount and the remainder\n    * @param amount_record The record to split\n    * @param url The url of the Aleo network node to send the transaction to\n    * @param cache Cache the proving and verifying keys in the ProgramManager memory. If this is\n    * set to `true` the keys synthesized (or passed in as optional parameters via the\n    * `split_proving_key` and `split_verifying_key` arguments) will be stored in the\n    * ProgramManager's memory and used for subsequent transactions. If this is set to `false` the\n    * proving and verifying keys will be deallocated from memory after the transaction is executed\n    * @param split_proving_key (optional) Provide a proving key to use for the split function\n    * @param split_verifying_key (optional) Provide a verifying key to use for the split function\n    * @param {PrivateKey} private_key\n    * @param {number} split_amount\n    * @param {RecordPlaintext} amount_record\n    * @param {string} url\n    * @param {boolean} cache\n    * @param {ProvingKey | undefined} split_proving_key\n    * @param {VerifyingKey | undefined} split_verifying_key\n    * @returns {Promise<Transaction>}\n    */\n    split(private_key, split_amount, amount_record, url, cache, split_proving_key, split_verifying_key) {\n        _assertClass(private_key, PrivateKey);\n        var ptr0 = private_key.__destroy_into_raw();\n        _assertClass(amount_record, RecordPlaintext);\n        var ptr1 = amount_record.__destroy_into_raw();\n        const ptr2 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        let ptr3 = 0;\n        if (!isLikeNone(split_proving_key)) {\n            _assertClass(split_proving_key, ProvingKey);\n            ptr3 = split_proving_key.__destroy_into_raw();\n        }\n        let ptr4 = 0;\n        if (!isLikeNone(split_verifying_key)) {\n            _assertClass(split_verifying_key, VerifyingKey);\n            ptr4 = split_verifying_key.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_split(this.__wbg_ptr, ptr0, split_amount, ptr1, ptr2, len2, cache, ptr3, ptr4);\n        return takeObject(ret);\n    }\n    /**\n    * Send credits from one Aleo account to another\n    *\n    * @param private_key The private key of the sender\n    * @param amount_credits The amount of credits to send\n    * @param recipient The recipient of the transaction\n    * @param transfer_type The type of the transfer (options: \"private\", \"public\", \"private_to_public\", \"public_to_private\")\n    * @param amount_record The record to fund the amount from\n    * @param fee_credits The amount of credits to pay as a fee\n    * @param fee_record The record to spend the fee from\n    * @param url The url of the Aleo network node to send the transaction to\n    * @param cache Cache the proving and verifying keys in the ProgramManager memory. If this is\n    * set to `true` the keys synthesized (or passed in as optional parameters via the\n    * `transfer_proving_key` and `transfer_verifying_key` arguments) will be stored in the\n    * ProgramManager's memory and used for subsequent transactions. If this is set to `false` the\n    * proving and verifying keys will be deallocated from memory after the transaction is executed\n    * @param transfer_proving_key (optional) Provide a proving key to use for the transfer\n    * function\n    * @param transfer_verifying_key (optional) Provide a verifying key to use for the transfer\n    * function\n    * @param fee_proving_key (optional) Provide a proving key to use for the fee execution\n    * @param fee_verifying_key (optional) Provide a verifying key to use for the fee execution\n    * @param {PrivateKey} private_key\n    * @param {number} amount_credits\n    * @param {string} recipient\n    * @param {string} transfer_type\n    * @param {RecordPlaintext | undefined} amount_record\n    * @param {number} fee_credits\n    * @param {RecordPlaintext} fee_record\n    * @param {string} url\n    * @param {boolean} cache\n    * @param {ProvingKey | undefined} transfer_proving_key\n    * @param {VerifyingKey | undefined} transfer_verifying_key\n    * @param {ProvingKey | undefined} fee_proving_key\n    * @param {VerifyingKey | undefined} fee_verifying_key\n    * @returns {Promise<Transaction>}\n    */\n    transfer(private_key, amount_credits, recipient, transfer_type, amount_record, fee_credits, fee_record, url, cache, transfer_proving_key, transfer_verifying_key, fee_proving_key, fee_verifying_key) {\n        _assertClass(private_key, PrivateKey);\n        var ptr0 = private_key.__destroy_into_raw();\n        const ptr1 = passStringToWasm0(recipient, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ptr2 = passStringToWasm0(transfer_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len2 = WASM_VECTOR_LEN;\n        let ptr3 = 0;\n        if (!isLikeNone(amount_record)) {\n            _assertClass(amount_record, RecordPlaintext);\n            ptr3 = amount_record.__destroy_into_raw();\n        }\n        _assertClass(fee_record, RecordPlaintext);\n        var ptr4 = fee_record.__destroy_into_raw();\n        const ptr5 = passStringToWasm0(url, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len5 = WASM_VECTOR_LEN;\n        let ptr6 = 0;\n        if (!isLikeNone(transfer_proving_key)) {\n            _assertClass(transfer_proving_key, ProvingKey);\n            ptr6 = transfer_proving_key.__destroy_into_raw();\n        }\n        let ptr7 = 0;\n        if (!isLikeNone(transfer_verifying_key)) {\n            _assertClass(transfer_verifying_key, VerifyingKey);\n            ptr7 = transfer_verifying_key.__destroy_into_raw();\n        }\n        let ptr8 = 0;\n        if (!isLikeNone(fee_proving_key)) {\n            _assertClass(fee_proving_key, ProvingKey);\n            ptr8 = fee_proving_key.__destroy_into_raw();\n        }\n        let ptr9 = 0;\n        if (!isLikeNone(fee_verifying_key)) {\n            _assertClass(fee_verifying_key, VerifyingKey);\n            ptr9 = fee_verifying_key.__destroy_into_raw();\n        }\n        const ret = wasm.programmanager_transfer(this.__wbg_ptr, ptr0, amount_credits, ptr1, len1, ptr2, len2, ptr3, fee_credits, ptr4, ptr5, len5, cache, ptr6, ptr7, ptr8, ptr9);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nclass ProvingKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ProvingKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_provingkey_free(ptr);\n    }\n    /**\n    * Construct a new proving key from a byte array\n    * @param {Uint8Array} bytes\n    * @returns {ProvingKey}\n    */\n    static fromBytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.provingkey_fromBytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return ProvingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a byte array from a proving key\n    * @returns {Uint8Array}\n    */\n    toBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.provingkey_toBytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* Encrypted Aleo record\n*/\nclass RecordCiphertext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RecordCiphertext.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_recordciphertext_free(ptr);\n    }\n    /**\n    * Return a record ciphertext from a string.\n    * @param {string} record\n    * @returns {RecordCiphertext}\n    */\n    static fromString(record) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.recordciphertext_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordCiphertext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Return the record ciphertext string.\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordciphertext_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Decrypt the record ciphertext into plaintext using the view key.\n    * @param {ViewKey} view_key\n    * @returns {RecordPlaintext}\n    */\n    decrypt(view_key) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(view_key, ViewKey);\n            wasm.recordciphertext_decrypt(retptr, this.__wbg_ptr, view_key.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordPlaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns `true` if the view key can decrypt the record ciphertext.\n    * @param {ViewKey} view_key\n    * @returns {boolean}\n    */\n    isOwner(view_key) {\n        _assertClass(view_key, ViewKey);\n        const ret = wasm.recordciphertext_isOwner(this.__wbg_ptr, view_key.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n* Aleo record plaintext\n*/\nclass RecordPlaintext {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RecordPlaintext.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_recordplaintext_free(ptr);\n    }\n    /**\n    * Return a record plaintext from a string.\n    * @param {string} record\n    * @returns {RecordPlaintext}\n    */\n    static fromString(record) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(record, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return RecordPlaintext.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Returns the record plaintext string\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.recordplaintext_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Returns the amount of microcredits in the record\n    * @returns {bigint}\n    */\n    microcredits() {\n        const ret = wasm.recordplaintext_microcredits(this.__wbg_ptr);\n        return BigInt.asUintN(64, ret);\n    }\n    /**\n    * Attempt to get the serial number of a record to determine whether or not is has been spent\n    * @param {PrivateKey} private_key\n    * @param {string} program_id\n    * @param {string} record_name\n    * @returns {string}\n    */\n    serialNumberString(private_key, program_id, record_name) {\n        let deferred4_0;\n        let deferred4_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(private_key, PrivateKey);\n            const ptr0 = passStringToWasm0(program_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            const ptr1 = passStringToWasm0(record_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len1 = WASM_VECTOR_LEN;\n            wasm.recordplaintext_serialNumberString(retptr, this.__wbg_ptr, private_key.__wbg_ptr, ptr0, len0, ptr1, len1);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr3 = r0;\n            var len3 = r1;\n            if (r3) {\n                ptr3 = 0; len3 = 0;\n                throw takeObject(r2);\n            }\n            deferred4_0 = ptr3;\n            deferred4_1 = len3;\n            return getStringFromWasm0(ptr3, len3);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred4_0, deferred4_1, 1);\n        }\n    }\n}\n/**\n*/\nclass Signature {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Signature.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_signature_free(ptr);\n    }\n    /**\n    * @param {PrivateKey} private_key\n    * @param {Uint8Array} message\n    * @returns {Signature}\n    */\n    static sign(private_key, message) {\n        _assertClass(private_key, PrivateKey);\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signature_sign(private_key.__wbg_ptr, ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n    * @param {Address} address\n    * @param {Uint8Array} message\n    * @returns {boolean}\n    */\n    verify(address, message) {\n        _assertClass(address, Address);\n        const ptr0 = passArray8ToWasm0(message, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signature_verify(this.__wbg_ptr, address.__wbg_ptr, ptr0, len0);\n        return ret !== 0;\n    }\n    /**\n    * @param {string} signature\n    * @returns {Signature}\n    */\n    static from_string(signature) {\n        const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.signature_from_string(ptr0, len0);\n        return Signature.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.signature_to_string(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n/**\n* Webassembly Representation of an Aleo transaction\n*\n* This object is created when generating an on-chain function deployment or execution and is the\n* object that should be submitted to the Aleo Network in order to deploy or execute a function.\n*/\nclass Transaction {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(Transaction.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_transaction_free(ptr);\n    }\n    /**\n    * Create a transaction from a string\n    * @param {string} transaction\n    * @returns {Transaction}\n    */\n    static fromString(transaction) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(transaction, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.transaction_fromString(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Transaction.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Get the transaction as a string. If you want to submit this transaction to the Aleo Network\n    * this function will create the string that should be submitted in the `POST` data.\n    * @returns {string}\n    */\n    toString() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_toString(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Get the id of the transaction. This is the merkle root of the transaction's inclusion proof.\n    *\n    * This value can be used to query the status of the transaction on the Aleo Network to see\n    * if it was successful. If successful, the transaction will be included in a block and this\n    * value can be used to lookup the transaction data on-chain.\n    * @returns {string}\n    */\n    transactionId() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_transactionId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * Get the type of the transaction (will return \"deploy\" or \"execute\")\n    * @returns {string}\n    */\n    transactionType() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.transaction_transactionType(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n}\n/**\n*/\nclass VerifyingKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(VerifyingKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_verifyingkey_free(ptr);\n    }\n    /**\n    * Construct a new verifying key from a byte array\n    * @param {Uint8Array} bytes\n    * @returns {VerifyingKey}\n    */\n    static fromBytes(bytes) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.verifyingkey_fromBytes(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return VerifyingKey.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Create a byte array from a verifying key\n    * @returns {Uint8Array}\n    */\n    toBytes() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.verifyingkey_toBytes(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            if (r3) {\n                throw takeObject(r2);\n            }\n            var v1 = getArrayU8FromWasm0(r0, r1).slice();\n            wasm.__wbindgen_free(r0, r1 * 1);\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nclass ViewKey {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(ViewKey.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_viewkey_free(ptr);\n    }\n    /**\n    * @param {PrivateKey} private_key\n    * @returns {ViewKey}\n    */\n    static from_private_key(private_key) {\n        _assertClass(private_key, PrivateKey);\n        const ret = wasm.viewkey_from_private_key(private_key.__wbg_ptr);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n    * @param {string} view_key\n    * @returns {ViewKey}\n    */\n    static from_string(view_key) {\n        const ptr0 = passStringToWasm0(view_key, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.viewkey_from_string(ptr0, len0);\n        return ViewKey.__wrap(ret);\n    }\n    /**\n    * @returns {string}\n    */\n    to_string() {\n        let deferred1_0;\n        let deferred1_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.viewkey_to_string(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            deferred1_0 = r0;\n            deferred1_1 = r1;\n            return getStringFromWasm0(r0, r1);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n        }\n    }\n    /**\n    * @returns {Address}\n    */\n    to_address() {\n        const ret = wasm.viewkey_to_address(this.__wbg_ptr);\n        return Address.__wrap(ret);\n    }\n    /**\n    * @param {string} ciphertext\n    * @returns {string}\n    */\n    decrypt(ciphertext) {\n        let deferred3_0;\n        let deferred3_1;\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(ciphertext, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.viewkey_decrypt(retptr, this.__wbg_ptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            var r3 = getInt32Memory0()[retptr / 4 + 3];\n            var ptr2 = r0;\n            var len2 = r1;\n            if (r3) {\n                ptr2 = 0; len2 = 0;\n                throw takeObject(r2);\n            }\n            deferred3_0 = ptr2;\n            deferred3_1 = len2;\n            return getStringFromWasm0(ptr2, len2);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            wasm.__wbindgen_free(deferred3_0, deferred3_1, 1);\n        }\n    }\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_transaction_new = function(arg0) {\n        const ret = Transaction.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_log_38c939a5213b1be2 = function(arg0, arg1) {\n        console.log(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'string' ? obj : undefined;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        const ret = false;\n        return ret;\n    };\n    imports.wbg.__wbg_new_abda76e883ba8a5f = function() {\n        const ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {\n        const ret = getObject(arg1).stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_fetch_57429b87be3dcc33 = function(arg0) {\n        const ret = fetch(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_fetch_8eaf01857a5bb21f = function(arg0, arg1) {\n        const ret = getObject(arg0).fetch(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_signal_4bd18fb489af2d4c = function(arg0) {\n        const ret = getObject(arg0).signal;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_55c9955722952374 = function() { return handleError(function () {\n        const ret = new AbortController();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_abort_654b796176d117aa = function(arg0) {\n        getObject(arg0).abort();\n    };\n    imports.wbg.__wbg_status_114ef6fe27fb8b00 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_response_f2acf2ecbe021710 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).response;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_responseText_da275667251fd153 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg1).responseText;\n        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    }, arguments) };\n    imports.wbg.__wbg_new_daafff584c71593b = function() { return handleError(function () {\n        const ret = new XMLHttpRequest();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_open_56fa1eb95989f6a5 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5) {\n        getObject(arg0).open(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4), arg5 !== 0);\n    }, arguments) };\n    imports.wbg.__wbg_overrideMimeType_1a661d17da5f8baf = function() { return handleError(function (arg0, arg1, arg2) {\n        getObject(arg0).overrideMimeType(getStringFromWasm0(arg1, arg2));\n    }, arguments) };\n    imports.wbg.__wbg_send_9f5007eae908c72e = function() { return handleError(function (arg0) {\n        getObject(arg0).send();\n    }, arguments) };\n    imports.wbg.__wbg_instanceof_Response_fc4327dbfcdf5ced = function(arg0) {\n        let result;\n        try {\n            result = getObject(arg0) instanceof Response;\n        } catch {\n            result = false;\n        }\n        const ret = result;\n        return ret;\n    };\n    imports.wbg.__wbg_url_8503de97f69da463 = function(arg0, arg1) {\n        const ret = getObject(arg1).url;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbg_status_ac85a3142a84caa2 = function(arg0) {\n        const ret = getObject(arg0).status;\n        return ret;\n    };\n    imports.wbg.__wbg_headers_b70de86b8e989bc0 = function(arg0) {\n        const ret = getObject(arg0).headers;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_arrayBuffer_288fb3538806e85c = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).arrayBuffer();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_newwithstrandinit_cad5cd6038c7ff5d = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = new Request(getStringFromWasm0(arg0, arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_1eead62f64ca15ce = function() { return handleError(function () {\n        const ret = new Headers();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_append_fda9e3432e3e88da = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        getObject(arg0).append(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));\n    }, arguments) };\n    imports.wbg.__wbg_crypto_c48a774b022d20ac = function(arg0) {\n        const ret = getObject(arg0).crypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg_process_298734cf255a885d = function(arg0) {\n        const ret = getObject(arg0).process;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_versions_e2e78e134e3e5d01 = function(arg0) {\n        const ret = getObject(arg0).versions;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_node_1cd7a5d853dbea79 = function(arg0) {\n        const ret = getObject(arg0).node;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_is_string = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'string';\n        return ret;\n    };\n    imports.wbg.__wbg_msCrypto_bcb970640f50a1e8 = function(arg0) {\n        const ret = getObject(arg0).msCrypto;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_require_8f08ceecec0f4fee = function() { return handleError(function () {\n        const ret = module.require;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbg_getRandomValues_37fa2ca9e4e07fab = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).getRandomValues(getObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_randomFillSync_dc1e9a60c158336d = function() { return handleError(function (arg0, arg1) {\n        getObject(arg0).randomFillSync(takeObject(arg1));\n    }, arguments) };\n    imports.wbg.__wbg_get_44be0491f933a435 = function(arg0, arg1) {\n        const ret = getObject(arg0)[arg1 >>> 0];\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_length_fff51ee6522a1a18 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_newnoargs_581967eacc0e2604 = function(arg0, arg1) {\n        const ret = new Function(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_next_526fc47e980da008 = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_next_ddb3312ca1c4e32a = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_done_5c1f01fb660d73b5 = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_value_1695675138684bd5 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_iterator_97f0c81209c6c35a = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_97b561fb56f034b5 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_cb65541d95d71282 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_b51585de1b234aff = function() {\n        const ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_self_1ff1d729e9aae938 = function() { return handleError(function () {\n        const ret = self.self;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_window_5f4faef6c12b79ec = function() { return handleError(function () {\n        const ret = window.window;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_globalThis_1d39714405582d3c = function() { return handleError(function () {\n        const ret = globalThis.globalThis;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_global_651f05c6a0944d1c = function() { return handleError(function () {\n        const ret = __webpack_require__.g.global;\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        const ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg_newwithlength_3ec098a360da1909 = function(arg0) {\n        const ret = new Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_502d29070ea18557 = function(arg0, arg1, arg2) {\n        getObject(arg0)[arg1 >>> 0] = takeObject(arg2);\n    };\n    imports.wbg.__wbg_call_01734de55d61e11d = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_new_43f1b47c28813cbd = function(arg0, arg1) {\n        try {\n            var state0 = {a: arg0, b: arg1};\n            var cb0 = (arg0, arg1) => {\n                const a = state0.a;\n                state0.a = 0;\n                try {\n                    return __wbg_adapter_188(a, state0.b, arg0, arg1);\n                } finally {\n                    state0.a = a;\n                }\n            };\n            const ret = new Promise(cb0);\n            return addHeapObject(ret);\n        } finally {\n            state0.a = state0.b = 0;\n        }\n    };\n    imports.wbg.__wbg_resolve_53698b95aaf7fcf8 = function(arg0) {\n        const ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_f7e06ee3c11698eb = function(arg0, arg1) {\n        const ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_then_b2267541e2a73865 = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_085ec1f694018c4f = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_6da8e527659b86aa = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_8125e318e6245eed = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_5cf90238115182c3 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_length_72e2208bbc0efc61 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_newwithlength_e5d69174d6984cd7 = function(arg0) {\n        const ret = new Uint8Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_subarray_13db269f57aa838d = function(arg0, arg1, arg2) {\n        const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_has_c5fcd020291e56b8 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.has(getObject(arg0), getObject(arg1));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_set_092e06b0f9d71865 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));\n        return ret;\n    }, arguments) };\n    imports.wbg.__wbg_stringify_e25465938f3f611f = function() { return handleError(function (arg0) {\n        const ret = JSON.stringify(getObject(arg0));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len1;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr1;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_closure_wrapper6132 = function(arg0, arg1, arg2) {\n        const ret = makeMutClosure(arg0, arg1, 930, __wbg_adapter_26);\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, maybe_memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedInt32Memory0 = null;\n    cachedUint8Memory0 = null;\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n    const imports = __wbg_get_imports();\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(input) {\n    if (wasm !== undefined) return wasm;\n\n    if (typeof input === 'undefined') {\n        input = new URL(/* asset import */ __webpack_require__(/*! aleo_wasm_bg.wasm */ \"./aleo/wasm/pkg/aleo_wasm_bg.wasm\"), __webpack_require__.b);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await input, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__wbg_init);\n\n\n//# sourceURL=webpack://www/./aleo/wasm/pkg/aleo_wasm.js?");

/***/ }),

/***/ "./aleo/sdk/src/account.ts":
/*!*********************************!*\
  !*** ./aleo/sdk/src/account.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account)\n/* harmony export */ });\n/* harmony import */ var _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aleohq/nodejs */ \"./aleo/wasm/pkg/aleo_wasm.js\");\n\n/**\n * Key Management class. Enables the creation of a new Aleo Account, importation of an existing account from\n * an existing private key or seed, and message signing and verification functionality.\n *\n * An Aleo Account is generated from a randomly generated seed (number) from which an account private key, view key,\n * and a public account address are derived. The private key lies at the root of an Aleo account. It is a highly\n * sensitive secret and should be protected as it allows for creation of Aleo Program executions and arbitrary value\n * transfers. The View Key allows for decryption of a user's activity on the blockchain. The Address is the public\n * address to which other users of Aleo can send Aleo credits and other records to. This class should only be used\n * environments where the safety of the underlying key material can be assured.\n *\n * @example\n * // Create a new account\n * let myRandomAccount = new Account();\n *\n * // Create an account from a randomly generated seed\n * let seed = new Uint8Array([94, 91, 52, 251, 240, 230, 226, 35, 117, 253, 224, 210, 175, 13, 205, 120, 155, 214, 7, 169, 66, 62, 206, 50, 188, 40, 29, 122, 40, 250, 54, 18]);\n * let mySeededAccount = new Account({seed: seed});\n *\n * // Create an account from an existing private key\n * let myExistingAccount = new Account({privateKey: 'myExistingPrivateKey'})\n *\n * // Sign a message\n * let hello_world = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n * let signature = myRandomAccount.sign(hello_world)\n *\n * // Verify a signature\n * myRandomAccount.verify(hello_world, signature)\n */\nvar Account = /** @class */ (function () {\n    function Account(params) {\n        if (params === void 0) { params = {}; }\n        try {\n            this._privateKey = this.privateKeyFromParams(params);\n        }\n        catch (e) {\n            console.error(\"Wrong parameter\", e);\n            throw new Error(\"Wrong Parameter\");\n        }\n        this._viewKey = _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_0__.ViewKey.from_private_key(this._privateKey);\n        this._address = _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_0__.Address.from_private_key(this._privateKey);\n    }\n    /**\n     * Attempts to create an account from a private key ciphertext\n     * @param {PrivateKeyCiphertext | string} ciphertext\n     * @param {string} password\n     * @returns {PrivateKey | Error}\n     *\n     * @example\n     * let ciphertext = PrivateKey.newEncrypted(\"password\");\n     * let account = Account.fromCiphertext(ciphertext, \"password\");\n     */\n    Account.fromCiphertext = function (ciphertext, password) {\n        try {\n            ciphertext = (typeof ciphertext === \"string\") ? _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_0__.PrivateKeyCiphertext.fromString(ciphertext) : ciphertext;\n            var _privateKey = _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_0__.PrivateKey.fromPrivateKeyCiphertext(ciphertext, password);\n            return new Account({ privateKey: _privateKey.to_string() });\n        }\n        catch (e) {\n            throw new Error(\"Wrong password or invalid ciphertext\");\n        }\n    };\n    Account.prototype.privateKeyFromParams = function (params) {\n        if (params.seed) {\n            return _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_0__.PrivateKey.from_seed_unchecked(params.seed);\n        }\n        if (params.privateKey) {\n            return _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_0__.PrivateKey.from_string(params.privateKey);\n        }\n        return new _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_0__.PrivateKey();\n    };\n    Account.prototype.privateKey = function () {\n        return this._privateKey;\n    };\n    Account.prototype.viewKey = function () {\n        return this._viewKey;\n    };\n    Account.prototype.address = function () {\n        return this._address;\n    };\n    Account.prototype.toString = function () {\n        return this.address().to_string();\n    };\n    /**\n     * Encrypt the account's private key with a password\n     * @param {string} ciphertext\n     * @returns {PrivateKeyCiphertext}\n     *\n     * @example\n     * let account = new Account();\n     * let ciphertext = account.encryptAccount(\"password\");\n     */\n    Account.prototype.encryptAccount = function (password) {\n        return this._privateKey.toCiphertext(password);\n    };\n    /**\n     * Decrypts a Record in ciphertext form into plaintext\n     * @param {string} ciphertext\n     * @returns {Record}\n     *\n     * @example\n     * let account = new Account();\n     * let record = account.decryptRecord(\"record1ciphertext\");\n     */\n    Account.prototype.decryptRecord = function (ciphertext) {\n        return this._viewKey.decrypt(ciphertext);\n    };\n    /**\n     * Decrypts an array of Records in ciphertext form into plaintext\n     * @param {string[]} ciphertexts\n     * @returns {Record[]}\n     *\n     * @example\n     * let account = new Account();\n     * let record = account.decryptRecords([\"record1ciphertext\", \"record2ciphertext\"]);\n     */\n    Account.prototype.decryptRecords = function (ciphertexts) {\n        var _this = this;\n        return ciphertexts.map(function (ciphertext) { return _this._viewKey.decrypt(ciphertext); });\n    };\n    /**\n     * Determines whether the account owns a ciphertext record\n     * @param {RecordCipherText | string} ciphertext\n     * @returns {boolean}\n     *\n     * @example\n     * // Create a connection to the Aleo network and an account\n     * let connection = new NodeConnection(\"vm.aleo.org/api\");\n     * let account = Account.fromCiphertext(\"ciphertext\", \"password\");\n     *\n     * // Get a record from the network\n     * let record = connection.getBlock(1234);\n     * let recordCipherText = record.transactions[0].execution.transitions[0].id;\n     *\n     * // Check if the account owns the record\n     * if account.ownsRecord(recordCipherText) {\n     *     // Then one can do something like:\n     *     // Decrypt the record and check if it's spent\n     *     // Store the record in a local database\n     *     // Etc.\n     * }\n     */\n    Account.prototype.ownsRecordCiphertext = function (ciphertext) {\n        if (typeof ciphertext === 'string') {\n            try {\n                var ciphertextObject = _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_0__.RecordCiphertext.fromString(ciphertext);\n                return ciphertextObject.isOwner(this._viewKey);\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        else {\n            return ciphertext.isOwner(this._viewKey);\n        }\n    };\n    /**\n     * Signs a message with the account's private key.\n     * Returns a Signature.\n     *\n     * @param {Uint8Array} message\n     * @returns {Signature}\n     *\n     * @example\n     * let account = new Account();\n     * let message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n     * account.sign(message);\n     */\n    Account.prototype.sign = function (message) {\n        return this._privateKey.sign(message);\n    };\n    /**\n     * Verifies the Signature on a message.\n     *\n     * @param {Uint8Array} message\n     * @param {Signature} signature\n     * @returns {boolean}\n     *\n     * @example\n     * let account = new Account();\n     * let message = Uint8Array.from([104, 101, 108, 108, 111 119, 111, 114, 108, 100])\n     * let signature = account.sign(message);\n     * account.verify(message, signature);\n     */\n    Account.prototype.verify = function (message, signature) {\n        return this._address.verify(message, signature);\n    };\n    return Account;\n}());\n\n\n\n//# sourceURL=webpack://www/./aleo/sdk/src/account.ts?");

/***/ }),

/***/ "./aleo/sdk/src/aleo_network_client.ts":
/*!*********************************************!*\
  !*** ./aleo/sdk/src/aleo_network_client.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AleoNetworkClient: () => (/* binding */ AleoNetworkClient)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./aleo/sdk/node_modules/axios/lib/axios.js\");\n/* harmony import */ var _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aleohq/nodejs */ \"./aleo/wasm/pkg/aleo_wasm.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n/**\n * Connection management class that encapsulates REST calls to publicly exposed endpoints of Aleo nodes.\n * The methods provided in this class provide information on the Aleo Blockchain\n *\n * @param {string} host\n * @example\n * // Connection to a local node\n * let local_connection = new AleoNetworkClient(\"http://localhost:3030\");\n *\n * // Connection to a public beacon node\n * let public_connection = new AleoNetworkClient(\"https://vm.aleo.org/api\");\n */\nvar AleoNetworkClient = /** @class */ (function () {\n    function AleoNetworkClient(host) {\n        this.host = host + \"/testnet3\";\n    }\n    /**\n     * Set an account\n     *\n     * @param {Account} account\n     * @example\n     * let account = new Account();\n     * connection.setAccount(account);\n     */\n    AleoNetworkClient.prototype.setAccount = function (account) {\n        this.account = account;\n    };\n    /**\n     * Return the Aleo account used in the node connection\n     *\n     * @example\n     * let account = connection.getAccount();\n     */\n    AleoNetworkClient.prototype.getAccount = function () {\n        return this.account;\n    };\n    AleoNetworkClient.prototype.fetchData = function (url) {\n        if (url === void 0) { url = \"/\"; }\n        return __awaiter(this, void 0, void 0, function () {\n            var response, error_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(this.host + url)];\n                    case 1:\n                        response = _a.sent();\n                        return [2 /*return*/, response.data];\n                    case 2:\n                        error_1 = _a.sent();\n                        throw new Error(\"Error fetching data.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the block contents of the block at the specified block height\n     *\n     * @param {number} height\n     * @example\n     * let block = connection.getBlock(1234);\n     */\n    AleoNetworkClient.prototype.getBlock = function (height) {\n        return __awaiter(this, void 0, void 0, function () {\n            var block, error_2;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/block/\" + height)];\n                    case 1:\n                        block = _a.sent();\n                        return [2 /*return*/, block];\n                    case 2:\n                        error_2 = _a.sent();\n                        throw new Error(\"Error fetching block.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns a range of blocks between the specified block heights\n     *\n     * @param {number} start\n     * @param {number} end\n     * @example\n     * let blockRange = connection.getBlockRange(2050, 2100);\n     */\n    AleoNetworkClient.prototype.getBlockRange = function (start, end) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_3, errorMessage;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/blocks?start=\" + start + \"&end=\" + end)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_3 = _a.sent();\n                        errorMessage = \"Error fetching blocks between \" + start + \" and \" + end + \".\";\n                        throw new Error(errorMessage);\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the source code of a program\n     *\n     * @param {string} programId\n     * @example\n     * let program = connection.getProgram(\"foo.aleo\");\n     */\n    AleoNetworkClient.prototype.getProgram = function (programId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_4;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/program/\" + programId)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_4 = _a.sent();\n                        throw new Error(\"Error fetching program\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the names of the mappings of a program\n     *\n     * @param {string} programId\n     * @example\n     * let mappings = connection.getProgramMappingNames(\"credits.aleo\");\n     */\n    AleoNetworkClient.prototype.getProgramMappingNames = function (programId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_5;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/program/\" + programId + \"/mappings\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_5 = _a.sent();\n                        throw new Error(\"Error fetching program mappings - ensure the program exists on chain before trying again\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the value of a program's mapping for a specific key\n     *\n     * @param {string} programId\n     * @param {string} mappingName\n     * @param {string} key\n     * @example\n     * ## Get public balance of an account\n     * let mappingValue = connection.getMappingValue(\"credits.aleo\", \"account\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\");\n     */\n    AleoNetworkClient.prototype.getMappingValue = function (programId, mappingName, key) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_6;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/program/\" + programId + \"/mapping/\" + mappingName + \"/\" + key)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_6 = _a.sent();\n                        throw new Error(\"Error fetching mapping value - ensure the mapping exists and the key is correct\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the block contents of the latest block\n     *\n     * @example\n     * let latestHeight = connection.getLatestBlock();\n     */\n    AleoNetworkClient.prototype.getLatestBlock = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_7;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/latest/block\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_7 = _a.sent();\n                        throw new Error(\"Error fetching latest block.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the hash of the last published block\n     *\n     * @example\n     * let latestHash = connection.getLatestHash();\n     */\n    AleoNetworkClient.prototype.getLatestHash = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_8;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/latest/hash\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_8 = _a.sent();\n                        throw new Error(\"Error fetching latest hash.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the latest block height\n     *\n     * @example\n     * let latestHeight = connection.getLatestHeight();\n     */\n    AleoNetworkClient.prototype.getLatestHeight = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_9;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/latest/height\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_9 = _a.sent();\n                        throw new Error(\"Error fetching latest height.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the latest state/merkle root of the Aleo blockchain\n     *\n     * @example\n     * let stateRoot = connection.getStateRoot();\n     */\n    AleoNetworkClient.prototype.getStateRoot = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_10;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/latest/stateRoot\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_10 = _a.sent();\n                        throw new Error(\"Error fetching Aleo state root\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns a transaction by its unique identifier\n     *\n     * @param {string} id\n     * @example\n     * let transaction = connection.getTransaction(\"at1handz9xjrqeynjrr0xay4pcsgtnczdksz3e584vfsgaz0dh0lyxq43a4wj\");\n     */\n    AleoNetworkClient.prototype.getTransaction = function (id) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_11;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/transaction/\" + id)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_11 = _a.sent();\n                        throw new Error(\"Error fetching transaction.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the transactions present at the specified block height\n     *\n     * @param {number} height\n     * @example\n     * let transactions = connection.getTransactions(654);\n     */\n    AleoNetworkClient.prototype.getTransactions = function (height) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_12;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/block/\" + height.toString() + \"/transactions\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_12 = _a.sent();\n                        throw new Error(\"Error fetching transactions.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the transactions in the memory pool.\n     *\n     * @example\n     * let transactions = connection.getTransactionsInMempool();\n     */\n    AleoNetworkClient.prototype.getTransactionsInMempool = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_13;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/memoryPool/transactions\")];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_13 = _a.sent();\n                        throw new Error(\"Error fetching transactions from mempool.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the transition id by its unique identifier\n     *\n     * @example\n     * let transition = connection.getTransitionId(\"2429232855236830926144356377868449890830704336664550203176918782554219952323field\");\n     */\n    AleoNetworkClient.prototype.getTransitionId = function (transition_id) {\n        return __awaiter(this, void 0, void 0, function () {\n            var error_14;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.fetchData(\"/find/transitionID/\" + transition_id)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                    case 2:\n                        error_14 = _a.sent();\n                        throw new Error(\"Error fetching transition ID.\");\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Attempts to find unspent records in the Aleo blockchain for a specified private key\n     *\n     * @example\n     * // Find all unspent records\n     * const privateKey = \"[PRIVATE_KEY]\";\n     * let records = connection.findUnspentRecords(0, undefined, privateKey);\n     *\n     * // Find specific amounts\n     * const startHeight = 500000;\n     * const amounts = [600000, 1000000];\n     * let records = connection.findUnspentRecords(startHeight, undefined, privateKey, amounts);\n     *\n     * // Find specific amounts with a maximum number of cumulative microcredits\n     * const maxMicrocredits = 100000;\n     * let records = connection.findUnspentRecords(startHeight, undefined, privateKey, undefined, maxMicrocredits);\n     */\n    AleoNetworkClient.prototype.findUnspentRecords = function (startHeight, endHeight, privateKey, amounts, maxMicrocredits) {\n        return __awaiter(this, void 0, void 0, function () {\n            var records, start, end, resolvedPrivateKey, failures, totalRecordValue, latestHeight, viewKey, blockHeight, error_15, blocks, i, block, transactions, j, confirmedTransaction, transaction, k, transition, l, output, record, recordPlaintext, serialNumber, error_16, amounts_found, m, n, error_17, error_18;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // Ensure start height is not negative\n                        if (startHeight < 0) {\n                            throw new Error(\"Start height must be greater than or equal to 0\");\n                        }\n                        records = new Array();\n                        failures = 0;\n                        totalRecordValue = BigInt(0);\n                        // Ensure a private key is present to find owned records\n                        if (typeof privateKey === \"undefined\") {\n                            if (typeof this.account === \"undefined\") {\n                                throw new Error(\"Private key must be specified in an argument to findOwnedRecords or set in the AleoNetworkClient\");\n                            }\n                            else {\n                                resolvedPrivateKey = this.account._privateKey;\n                            }\n                        }\n                        else {\n                            try {\n                                resolvedPrivateKey = _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_1__.PrivateKey.from_string(privateKey);\n                            }\n                            catch (error) {\n                                throw new Error(\"Error parsing private key provided.\");\n                            }\n                        }\n                        viewKey = resolvedPrivateKey.to_view_key();\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this.getLatestHeight()];\n                    case 2:\n                        blockHeight = _a.sent();\n                        if (typeof blockHeight === \"number\") {\n                            latestHeight = blockHeight;\n                        }\n                        else {\n                            throw new Error(\"Error fetching latest block height.\");\n                        }\n                        return [3 /*break*/, 4];\n                    case 3:\n                        error_15 = _a.sent();\n                        throw new Error(\"Error fetching latest block height.\");\n                    case 4:\n                        // If no end height is specified or is greater than the latest height, set the end height to the latest height\n                        if (typeof endHeight === \"number\" && endHeight <= latestHeight) {\n                            end = endHeight;\n                        }\n                        else {\n                            end = latestHeight;\n                        }\n                        // If the starting is greater than the ending height, return an error\n                        if (startHeight > end) {\n                            throw new Error(\"Start height must be less than or equal to end height.\");\n                        }\n                        _a.label = 5;\n                    case 5:\n                        if (!(end > startHeight)) return [3 /*break*/, 25];\n                        start = end - 50;\n                        if (start < startHeight) {\n                            start = startHeight;\n                        }\n                        _a.label = 6;\n                    case 6:\n                        _a.trys.push([6, 23, , 24]);\n                        return [4 /*yield*/, this.getBlockRange(start, end)];\n                    case 7:\n                        blocks = _a.sent();\n                        end = start;\n                        if (!!(blocks instanceof Error)) return [3 /*break*/, 22];\n                        i = 0;\n                        _a.label = 8;\n                    case 8:\n                        if (!(i < blocks.length)) return [3 /*break*/, 22];\n                        block = blocks[i];\n                        transactions = block.transactions;\n                        if (!!(typeof transactions === \"undefined\")) return [3 /*break*/, 21];\n                        j = 0;\n                        _a.label = 9;\n                    case 9:\n                        if (!(j < transactions.length)) return [3 /*break*/, 21];\n                        confirmedTransaction = transactions[j];\n                        if (!(confirmedTransaction.type == \"execute\")) return [3 /*break*/, 20];\n                        transaction = confirmedTransaction.transaction;\n                        if (!(transaction.execution && !(typeof transaction.execution.transitions == \"undefined\"))) return [3 /*break*/, 20];\n                        k = 0;\n                        _a.label = 10;\n                    case 10:\n                        if (!(k < transaction.execution.transitions.length)) return [3 /*break*/, 20];\n                        transition = transaction.execution.transitions[k];\n                        // Only search for unspent records in credits.aleo (for now)\n                        if (transition.program !== \"credits.aleo\") {\n                            return [3 /*break*/, 19];\n                        }\n                        if (!!(typeof transition.outputs == \"undefined\")) return [3 /*break*/, 19];\n                        l = 0;\n                        _a.label = 11;\n                    case 11:\n                        if (!(l < transition.outputs.length)) return [3 /*break*/, 19];\n                        output = transition.outputs[l];\n                        if (!(output.type === \"record\")) return [3 /*break*/, 18];\n                        _a.label = 12;\n                    case 12:\n                        _a.trys.push([12, 17, , 18]);\n                        record = _aleohq_nodejs__WEBPACK_IMPORTED_MODULE_1__.RecordCiphertext.fromString(output.value);\n                        if (!record.isOwner(viewKey)) return [3 /*break*/, 16];\n                        recordPlaintext = record.decrypt(viewKey);\n                        serialNumber = recordPlaintext.serialNumberString(resolvedPrivateKey, \"credits.aleo\", \"credits\");\n                        _a.label = 13;\n                    case 13:\n                        _a.trys.push([13, 15, , 16]);\n                        return [4 /*yield*/, this.getTransitionId(serialNumber)];\n                    case 14:\n                        _a.sent();\n                        return [3 /*break*/, 16];\n                    case 15:\n                        error_16 = _a.sent();\n                        // If it's not found, add it to the list of unspent records\n                        records.push(recordPlaintext);\n                        // If the user specified a maximum number of microcredits, check if the search has found enough\n                        if (typeof maxMicrocredits === \"number\") {\n                            totalRecordValue = recordPlaintext.microcredits();\n                            // Exit if the search has found the amount specified\n                            if (totalRecordValue >= BigInt(maxMicrocredits)) {\n                                return [2 /*return*/, records];\n                            }\n                        }\n                        // If the user specified a list of amounts, check if the search has found them\n                        if (!(typeof amounts == \"undefined\")) {\n                            amounts_found = 0;\n                            for (m = 0; m < amounts.length; m++) {\n                                for (n = 0; m < records.length; n++) {\n                                    if (records[n].microcredits() >= BigInt(amounts[m])) {\n                                        amounts_found++;\n                                        // Exit if the search has found the amounts specified\n                                        if (amounts_found >= amounts.length) {\n                                            return [2 /*return*/, records];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        return [3 /*break*/, 16];\n                    case 16: return [3 /*break*/, 18];\n                    case 17:\n                        error_17 = _a.sent();\n                        return [3 /*break*/, 18];\n                    case 18:\n                        l++;\n                        return [3 /*break*/, 11];\n                    case 19:\n                        k++;\n                        return [3 /*break*/, 10];\n                    case 20:\n                        j++;\n                        return [3 /*break*/, 9];\n                    case 21:\n                        i++;\n                        return [3 /*break*/, 8];\n                    case 22: return [3 /*break*/, 24];\n                    case 23:\n                        error_18 = _a.sent();\n                        // If there is an error fetching blocks, log it and keep searching\n                        console.log(\"Error fetching blocks in range: \" + start.toString() + \"-\" + end.toString());\n                        console.log(\"Error: \", error_18);\n                        failures += 1;\n                        if (failures > 10) {\n                            console.log(\"10 failures fetching records reached. Returning records fetched so far\");\n                            return [2 /*return*/, records];\n                        }\n                        return [3 /*break*/, 24];\n                    case 24: return [3 /*break*/, 5];\n                    case 25: return [2 /*return*/, records];\n                }\n            });\n        });\n    };\n    return AleoNetworkClient;\n}());\n\n\n\n//# sourceURL=webpack://www/./aleo/sdk/src/aleo_network_client.ts?");

/***/ }),

/***/ "./aleo/sdk/src/development_client.ts":
/*!********************************************!*\
  !*** ./aleo/sdk/src/development_client.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DevelopmentClient: () => (/* binding */ DevelopmentClient),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./aleo/sdk/node_modules/axios/lib/axios.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar config = {\n    headers: {\n        \"Content-type\": \"application/json; charset=UTF-8\",\n        \"Referrer-Policy\": \"no-referrer\"\n    },\n};\nvar DevelopmentClient = /** @class */ (function () {\n    /**\n     * Creates a new DevelopmentClient to interact with an Aleo Development Server.\n     *\n     * @param {string} baseURL The URL of the Aleo Development Server\n     */\n    function DevelopmentClient(baseURL) {\n        this.baseURL = baseURL;\n    }\n    DevelopmentClient.prototype.sendRequest = function (path, request) {\n        return __awaiter(this, void 0, void 0, function () {\n            var response;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"\".concat(this.baseURL, \"/testnet3\").concat(path), request, config)];\n                    case 1:\n                        response = _a.sent();\n                        if (!(response.statusText = \"200\")) {\n                            throw new Error(\"Error sending request: \".concat(response.statusText));\n                        }\n                        return [4 /*yield*/, response.data];\n                    case 2: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Deploys a program on the Aleo Network via an Aleo development server.\n     * It requires an Aleo Development Server to be running remotely or locally.\n     * If one is not running, this function will throw an error.\n     *\n     * Information on how to run an Aleo Development Server can be found here:\n     * https://github.com/AleoHQ/sdk/rust/develop/README.md\n     * @param {string} program Text representation of the program to be deployed\n     * @param {number} fee Fee to be paid for the program deployment (REQUIRED)\n     * @param {string | undefined} privateKey Optional private key of the user who is deploying the program\n     * @param {string | undefined} password If the development server is started with an encrypted private key, the password is required\n     * @param {string | undefined} feeRecord Optional record in text format to be used for the fee. If not provided, the server will search the network for a suitable record to pay the fee.\n     * @returns {string | Error} The transaction_id of the deployment transaction if successful\n     *\n     * @example\n     * const Program = 'program yourprogram.aleo;\\n\\nfunction hello:\\n    input r0 as u32.public;\\n    input r1 as u32.private;\\n    add r0 r1 into r2;\\n    output r2 as u32.private;\\n';\n     * const client = new DevelopmentClient(\"http://0.0.0.0:4040\");\n     * const transaction_id = await client.deployProgram(Program, 6000000, privateKeyString);\n     */\n    DevelopmentClient.prototype.deployProgram = function (program, fee, privateKey, password, feeRecord) {\n        return __awaiter(this, void 0, void 0, function () {\n            var request;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        request = {\n                            program: program,\n                            private_key: privateKey,\n                            password: password,\n                            fee: fee * 1000000,\n                            fee_record: feeRecord,\n                        };\n                        return [4 /*yield*/, this.sendRequest('/deploy', request)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Executes a program on the Aleo Network via an Aleo development server.\n     * It requires an Aleo Development Server to be running remotely or locally.\n     * If one is not running, this function will throw an error.\n     *\n     * Information on how to run an Aleo Development Server can be found here:\n     * https://github.com/AleoHQ/sdk/rust/develop/README.md\n     * @param {string} programId The program_id of the program to be executed (e.g. hello.aleo)\n     * @param {string} programFunction The function to execute within the program (e.g. hello)\n     * @param {number} fee Optional Fee to be paid for the execution transaction, specify 0 for no fee\n     * @param {string[]} inputs Array of inputs to be passed to the program\n     * @param {string | undefined} privateKey Optional private key of the user who is executing the program\n     * @param {string | undefined} password If the development server is started with an encrypted private key, the password is required\n     * @param {string | undefined} feeRecord Optional record in text format to be used for the fee. If not provided, the server will search the network for a suitable record to pay the fee.\n     * @returns {string | Error} The transaction_id of the execution transaction if successful\n     *\n     * @example\n     * const privateKey = \"your private key\";\n     * const client = new DevelopmentClient(\"http://0.0.0.0:4040\");\n     * const transaction_id = await client.executeProgram(\"hello.aleo\", \"hello\", 0, [\"5u32\", \"5u32\"], privateKeyString);\n     */\n    DevelopmentClient.prototype.executeProgram = function (programId, programFunction, fee, inputs, privateKey, password, feeRecord) {\n        return __awaiter(this, void 0, void 0, function () {\n            var request;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        request = {\n                            program_id: programId,\n                            program_function: programFunction,\n                            inputs: inputs,\n                            private_key: privateKey,\n                            password: password,\n                            fee: fee * 1000000,\n                            fee_record: feeRecord\n                        };\n                        return [4 /*yield*/, this.sendRequest('/execute', request)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    /**\n     * Sends an amount in credits to a specified recipient on the Aleo Network\n     * via an Aleo development server. It requires an Aleo Development Server\n     * to be running remotely or locally. If one is not running, this function\n     * will throw an error.\n     *\n     * Information on how to run an Aleo Development Server can be found here:\n     * https://github.com/AleoHQ/sdk/rust/develop/README.md\n     * @param {string} amount The amount of credits to be sent (e.g. 1.5)\n     * @param {number} fee Optional Fee to be paid for the transfer, specify 0 for no fee\n     * @param {string} recipient The recipient of the transfer\n     * @param {string} transfer_type The type of the transfer (possible values are \"private\", \"public\", \"private_to_public\", \"public_to_private\")\n     * @param {string | undefined} privateKey Optional private key of the user who is sending the transfer\n     * @param {string | undefined} password If the development server is started with an encrypted private key, the password is required\n     * @param {string | undefined} feeRecord Optional record in text format to be used for the fee. If not provided, the server will search the network for a suitable record to pay the fee.\n     * @param {string | undefined} amountRecord Optional record in text format to be used to fund the transfer. If not provided, the server will search the network for a suitable record to fund the amount.\n     * @returns {string | Error} The transaction_id of the execution transaction if successful\n     *\n     * @example\n     * const privateKey = \"your private key\";\n     * const recipient = \"recipient's address\";\n     * const client = new DevelopmentClient(\"http://0.0.0.0:4040\");\n     * const transaction_id = await client.transfer(1.5, 0, recipient, privateKey);\n     */\n    DevelopmentClient.prototype.transfer = function (amount, fee, recipient, transfer_type, privateKey, password, feeRecord, amountRecord) {\n        return __awaiter(this, void 0, void 0, function () {\n            var request;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        request = {\n                            amount: amount * 1000000,\n                            fee: fee * 1000000,\n                            transfer_type: transfer_type,\n                            recipient: recipient,\n                            private_key: privateKey,\n                            password: password,\n                            fee_record: feeRecord,\n                            amount_record: amountRecord\n                        };\n                        return [4 /*yield*/, this.sendRequest('/transfer', request)];\n                    case 1: return [2 /*return*/, _a.sent()];\n                }\n            });\n        });\n    };\n    return DevelopmentClient;\n}());\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DevelopmentClient);\n\n\n//# sourceURL=webpack://www/./aleo/sdk/src/development_client.ts?");

/***/ }),

/***/ "./src/aleo.ts":
/*!*********************!*\
  !*** ./src/aleo.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aleoInitializeBoard: () => (/* binding */ aleoInitializeBoard),\n/* harmony export */   aleoMovePiece: () => (/* binding */ aleoMovePiece),\n/* harmony export */   aleoUrl: () => (/* binding */ aleoUrl),\n/* harmony export */   aleoWhisperPiece: () => (/* binding */ aleoWhisperPiece),\n/* harmony export */   developUrl: () => (/* binding */ developUrl),\n/* harmony export */   developerClient: () => (/* binding */ developerClient),\n/* harmony export */   getFirstUnspentRecord: () => (/* binding */ getFirstUnspentRecord),\n/* harmony export */   isError: () => (/* binding */ isError),\n/* harmony export */   newAleoClient: () => (/* binding */ newAleoClient),\n/* harmony export */   nodeConnection: () => (/* binding */ nodeConnection),\n/* harmony export */   updateMoveInfo: () => (/* binding */ updateMoveInfo)\n/* harmony export */ });\n/* harmony import */ var _login__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./login */ \"./src/login.ts\");\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./game */ \"./src/game.ts\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event */ \"./src/event.ts\");\n/* harmony import */ var _chess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chess */ \"./src/chess.ts\");\n/* harmony import */ var _location__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./location */ \"./src/location.ts\");\n/* harmony import */ var _aleo_sdk_src_aleo_network_client__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../aleo/sdk/src/aleo_network_client */ \"./aleo/sdk/src/aleo_network_client.ts\");\n/* harmony import */ var _aleo_sdk_src_development_client__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../aleo/sdk/src/development_client */ \"./aleo/sdk/src/development_client.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n\n\n\n// import { Transaction } from \"@aleohq/sdk\";\nvar Long = __webpack_require__(/*! long */ \"./node_modules/long/umd/index.js\");\nvar moveInfo;\nfunction isError(result) {\n    return result instanceof Error;\n}\nfunction updateMoveInfo(gameId, x, y, targetX, targetY, attackResult, flagX, flagY, oppFlagX, oppFlagY, gameWinner) {\n    moveInfo = \"{\\n                gameId:\\\"\".concat(gameId, \"u64\\\",\\n                player: \").concat(_game__WEBPACK_IMPORTED_MODULE_1__.Game.getInstance(gameId).getLocalAddresses(), \",\\n                x:\\\"\").concat(x, \"u32\\\",\\n                y:\\\"\").concat(y, \"u32\\\",\\n                target_x: \\\"\").concat(targetX, \"u32\\\",\\n                target_y: \\\"\").concat(targetY, \"u32\\\",\\n                attack_result: \\\"\").concat(attackResult, \"u32\\\" // 0: simple move, 1: win, 2: draw, 3: lose\\n                flag_x: \\\"\").concat(flagX, \"u64\\\",\\n                flag_y: \\\"\").concat(flagY, \"u32\\\",\\n                opp_flag_x: \\\"\").concat(oppFlagX, \"u64\\\",\\n                opp_flag_y: \\\"\").concat(oppFlagY, \"u32\\\",\\n                game_winner: \\\"\").concat(gameWinner, \"u32\\\"\\n              }\");\n    console.log(\"updateMoveInfo result:\".concat(moveInfo));\n}\nvar aleoUrl = \"http://127.0.0.1:3030\";\nvar developUrl = \"http://127.0.0.1:4040\";\nvar nodeConnection;\nvar developerClient;\nvar transactionId = \"\";\nvar programId = \"land_battle_chess.aleo\";\nfunction getFirstUnspentRecord(privateKey) {\n    return __awaiter(this, void 0, void 0, function () {\n        var res, lastHeight, response1, texts, _i, texts_1, text;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, nodeConnection.getLatestHeight()];\n                case 1:\n                    res = _a.sent();\n                    if (isError(res)) {\n                        alert(\"Error fetching latest block error:.\");\n                        return [2 /*return*/];\n                    }\n                    lastHeight = res;\n                    console.log(\"lastHeight:\", lastHeight, \" privateKey:\", privateKey, \" begin to find unspend record\");\n                    return [4 /*yield*/, nodeConnection.findUnspentRecords(0, lastHeight, privateKey, undefined, undefined)];\n                case 2:\n                    response1 = _a.sent();\n                    if (isError(response1)) {\n                        alert(\"Error fetching latest block error:.\");\n                        return [2 /*return*/];\n                    }\n                    texts = response1;\n                    for (_i = 0, texts_1 = texts; _i < texts_1.length; _i++) {\n                        text = texts_1[_i];\n                        if (text.microcredits() > BigInt(1000)) {\n                            console.log(\"find record \".concat(text.toString()));\n                            return [2 /*return*/, text];\n                        }\n                    }\n                    return [2 /*return*/, undefined];\n            }\n        });\n    });\n}\nfunction newAleoClient(url, devUrl) {\n    if (devUrl === void 0) { devUrl = developUrl; }\n    console.log(\"init newAleoClinet....\");\n    nodeConnection = new _aleo_sdk_src_aleo_network_client__WEBPACK_IMPORTED_MODULE_5__.AleoNetworkClient(url);\n    developerClient = new _aleo_sdk_src_development_client__WEBPACK_IMPORTED_MODULE_6__.DevelopmentClient(devUrl);\n}\nfunction getInitLinePiece() {\n    var lines = [Long.UZERO, Long.UZERO, Long.UZERO, Long.UZERO, Long.UZERO];\n    var flagXStr = 0;\n    var flagYStr = 0;\n    for (var x = 0; x < 5; x++) {\n        for (var y = 0; y < 11; y++) {\n            var _a = _game__WEBPACK_IMPORTED_MODULE_1__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_0__.gameId).isPlayer1() ? [x, y] : (0,_location__WEBPACK_IMPORTED_MODULE_4__.getRevertLocation)(x, y), revX = _a[0], revY = _a[1];\n            var chess = _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(revX, revY).getChess();\n            if (chess == null) {\n                lines[x] = lines[x].or(Long.fromNumber(0).shiftLeft(5 * x));\n                continue;\n            }\n            if (chess.rank == _chess__WEBPACK_IMPORTED_MODULE_3__.Rank.Flag && chess.address == _game__WEBPACK_IMPORTED_MODULE_1__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_0__.gameId).getLocalAddresses()) {\n                flagXStr = revX;\n                flagYStr = revY;\n            }\n            lines[x] = lines[x].or(Long.fromNumber(chess.rank).shiftLeft(5 * x));\n        }\n    }\n    var newLines = lines.map(function (line) { return Long.fromNumber(line).toString() + \"u64\"; });\n    return [newLines, flagXStr, flagYStr];\n}\nfunction getRecordInfo() {\n    return __awaiter(this, void 0, void 0, function () {\n        var recordText, response, currentAccount_1, _i, _a, tx, output, error_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (!(transactionId === \"\")) return [3 /*break*/, 2];\n                    return [4 /*yield*/, (0,_login__WEBPACK_IMPORTED_MODULE_0__.sleep)(2000)];\n                case 1:\n                    _b.sent();\n                    return [3 /*break*/, 0];\n                case 2:\n                    recordText = \"\";\n                    _b.label = 3;\n                case 3:\n                    _b.trys.push([3, 5, , 6]);\n                    return [4 /*yield*/, nodeConnection.getTransaction(transactionId)];\n                case 4:\n                    response = _b.sent();\n                    if (response instanceof Error) {\n                        console.error(response);\n                        return [2 /*return*/, \"\"];\n                    }\n                    currentAccount_1 = _game__WEBPACK_IMPORTED_MODULE_1__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_0__.gameId).getCurrentAccount();\n                    for (_i = 0, _a = response.execution.transitions; _i < _a.length; _i++) {\n                        tx = _a[_i];\n                        output = tx.outputs.find(function (output) {\n                            return currentAccount_1.ownsRecordCiphertext(output.value);\n                        });\n                        if (output) {\n                            // 解密记录文本\n                            recordText = currentAccount_1.decryptRecord(output.value);\n                            console.log(recordText);\n                            break; // 跳出内层循环\n                        }\n                    }\n                    return [3 /*break*/, 6];\n                case 5:\n                    error_1 = _b.sent();\n                    console.error(error_1);\n                    return [3 /*break*/, 6];\n                case 6: return [2 /*return*/, recordText];\n            }\n        });\n    });\n}\n/**\n * player_initialize_board(line0: u64, line1: u64, line2: u64, line3: u64, line4: u64,\n        flag_x: u64, flag_y: u32, public game_id: u64, public player_index: u32, public arbiter: address) -> (player_state, bool)\n */\nfunction aleoInitializeBoard() {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, lines, flagXStr, flagYStr, arbiter, gameIdStr, playerIndexStr, privateKey;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _a = getInitLinePiece(), lines = _a[0], flagXStr = _a[1], flagYStr = _a[2];\n                    arbiter = _game__WEBPACK_IMPORTED_MODULE_1__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_0__.gameId).getArbiter();\n                    gameIdStr = _login__WEBPACK_IMPORTED_MODULE_0__.gameId + \"u64\";\n                    playerIndexStr = _game__WEBPACK_IMPORTED_MODULE_1__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_0__.gameId).isPlayer1 ? \"0u32\" : \"1u32\";\n                    console.log(\"aleoInitializeBoard\");\n                    privateKey = _game__WEBPACK_IMPORTED_MODULE_1__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_0__.gameId).getCurrentAccount().privateKey().to_string();\n                    // const record = await getFirstUnspentRecord(privateKey)\n                    // if (record == undefined){\n                    //   throw console.error(\"record is not find\")\n                    // }\n                    // transactionId = await developerClient.executeProgram(programId, \"player_initialize_board\", 10000, [ \"243944968059068u64\", \"243944970543153u64\" ,\"243944969889843u64\", \n                    // \"243944969494674u64\", \"243944969840532u64\", \"1u64\", \"0u32\", \"1u64\", \"1u32\", \"aleo1rhgdu77hgyqd3xjj8ucu3jj9r2krwz6mnzyd80gncr5fxcwlh5rsvzp9px\" ], privateKey, undefined, record.toString())\n                    // console.log(`aleoInitializeBoard,id:`, transactionId)\n                    updateMoveInfo(_login__WEBPACK_IMPORTED_MODULE_0__.gameId, 0, 0, 0, 0, 0, flagXStr, flagYStr, 0, 0, 0);\n                    return [4 /*yield*/, developerClient.executeProgram(programId, \"player_initialize_board\", 1000, [lines[0], lines[1], lines[2], lines[3],\n                            lines[4], flagXStr.toString() + \"u64\", flagYStr.toString() + \"u32\", gameIdStr, playerIndexStr, arbiter], privateKey, undefined)];\n                case 1:\n                    transactionId = _b.sent();\n                    console.log(\"aleoInitializeBoard,id:\", transactionId);\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * move_piece(state: player_state, public opp_move: move,\n        public x: u64, public y: u32, public target_x: u64, public target_y: u32) -> (player_state, piece_info)\n */\nfunction aleoMovePiece(x, y, targetX, targetY) {\n    return __awaiter(this, void 0, void 0, function () {\n        var privateKey;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    console.log(\"aleoMovePiece:(x:\".concat(x, \", y:\").concat(y, \" (targetx:\").concat(targetX, \", targety:\").concat(targetY, \")\"));\n                    privateKey = _game__WEBPACK_IMPORTED_MODULE_1__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_0__.gameId).getCurrentAccount().privateKey().to_string();\n                    return [4 /*yield*/, developerClient.executeProgram(programId, \"move_piece\", 1000, [moveInfo, \"\".concat(x.toString(), \"u64\"), \"\".concat(y.toString(), \"u32\"), \"\".concat(targetX.toString(), \"u64\"), \"\".concat(targetY.toString(), \"u32\")], privateKey, undefined)];\n                case 1:\n                    // transactionId = await developerClient.executeProgram(programId, \"move_piece\", 10000, [ moveInfo,\n                    //   `${x.toString()}u64`, `${y.toString()}u64`,\n                    //   `${targetX.toString()}u64`, `${targetY.toString()}u32` ], privateKey, undefined, record.toString())\n                    transactionId = _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * whisper_piece(state: player_state, public self_move: move, public target_x: u64, public target_y: u32) -> (player_state, piece_info) {\n        assert_eq(state.game_winner, 0u32);\n */\nfunction aleoWhisperPiece(targetX, targetY) {\n    return __awaiter(this, void 0, void 0, function () {\n        var privateKey, tx, txInfo, _i, _a, data;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    console.log(\"aleoWhisperPiece: (targetx:\".concat(targetX, \", targety:\").concat(targetY, \")\"));\n                    privateKey = _game__WEBPACK_IMPORTED_MODULE_1__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_0__.gameId).getCurrentAccount().privateKey().to_string();\n                    return [4 /*yield*/, developerClient.executeProgram(programId, \"whisper_piece\", 0, [moveInfo, \"\".concat(targetX.toString(), \"u64\"), \"\".concat(targetY.toString(), \"u32\")], privateKey, undefined, undefined)];\n                case 1:\n                    // transactionId = await developerClient.executeProgram(programId, \"whisper_piece\", 0, [moveInfo,\n                    //   `${targetX.toString()}u64`, `${targetY.toString()}u32`], privateKey, undefined, record.toString())\n                    transactionId = _b.sent();\n                    return [4 /*yield*/, nodeConnection.getTransaction(transactionId)];\n                case 2:\n                    tx = _b.sent();\n                    if (isError(tx)) {\n                        console.log(\"Failed to whisperPiece id:\".concat(_login__WEBPACK_IMPORTED_MODULE_0__.gameId, \" localAddress:\").concat(_game__WEBPACK_IMPORTED_MODULE_1__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_0__.gameId).getLocalAddresses()));\n                        return [2 /*return*/, \"\"];\n                    }\n                    txInfo = tx;\n                    for (_i = 0, _a = txInfo.execution.transitions; _i < _a.length; _i++) {\n                        data = _a[_i];\n                        console.log(\"+++++++++++++aleoWhisperPiece txInfo:\".concat(JSON.stringify(data), \"++++++++++++++++++\"));\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n\n\n//# sourceURL=webpack://www/./src/aleo.ts?");

/***/ }),

/***/ "./src/api.ts":
/*!********************!*\
  !*** ./src/api.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: () => (/* binding */ api),\n/* harmony export */   getGameId: () => (/* binding */ getGameId),\n/* harmony export */   pollGetGameId: () => (/* binding */ pollGetGameId)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"./node_modules/axios/lib/axios.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\nvar proxyExists = false;\n// 创建 Axios 实例\nvar api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: 'http://127.0.0.1:3000',\n    timeout: 5000, // 设置请求超时时间\n    // headers: {\n    //   'Access-Control-Allow-Origin': '*',\n    // },\n});\n// 检查代理是否存在，并根据情况进行配置\nif (proxyExists) {\n    api.defaults.proxy = {\n        host: 'your-proxy-host',\n        port: 8080, // 设置代理的端口号\n        // 可根据需要添加其他代理配置，例如身份验证等\n    };\n}\nfunction getGameId(address, accessCode) {\n    return __awaiter(this, void 0, void 0, function () {\n        var params, response, error_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    params = { pubkey: address, access_code: accessCode };\n                    return [4 /*yield*/, api.get(\"/join\", { params: params })];\n                case 1:\n                    response = _a.sent();\n                    if (response.status == 200) {\n                        console.log(\"getGameId:\", response.data.JoinResult.game_id);\n                        return [2 /*return*/, response.data.JoinResult.game_id];\n                    }\n                    return [3 /*break*/, 3];\n                case 2:\n                    error_1 = _a.sent();\n                    console.error('Error:', error_1);\n                    return [2 /*return*/, \"\"];\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction pollGetGameId(address) {\n    return __awaiter(this, void 0, void 0, function () {\n        var url, response, error_2;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 2, , 3]);\n                    url = \"/join/\".concat(address);\n                    return [4 /*yield*/, api.get(url)];\n                case 1:\n                    response = _a.sent();\n                    if (response.status == 200) {\n                        console.log(\"pollGetGameId:\", response.data.JoinResult.game_id);\n                        return [2 /*return*/, response.data.JoinResult.game_id];\n                    }\n                    return [2 /*return*/];\n                case 2:\n                    error_2 = _a.sent();\n                    console.error('Error:', error_2);\n                    return [2 /*return*/, \"\"];\n                case 3: return [2 /*return*/];\n            }\n        });\n    });\n}\n\n\n//# sourceURL=webpack://www/./src/api.ts?");

/***/ }),

/***/ "./src/board.ts":
/*!**********************!*\
  !*** ./src/board.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Board: () => (/* binding */ Board)\n/* harmony export */ });\n/* harmony import */ var _chess__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chess */ \"./src/chess.ts\");\n/* harmony import */ var _location__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./location */ \"./src/location.ts\");\n\n\nvar Board = /** @class */ (function () {\n    function Board(account, oppAddress) {\n        this.chessList = [];\n        this.locations = [];\n        this.rowCnt = 12;\n        this.columnCnt = 5;\n        for (var y = 0; y < this.rowCnt; y++) {\n            this.setLocationType(y);\n        }\n        // init chess rank\n        this.initChessList(account.toString(), oppAddress);\n        //init edge location\n        this.initLocationEdges();\n    }\n    Board.prototype.initChessList = function (address, oppAddress) {\n        var _this = this;\n        //司令、军长、师长、师长、旅长、旅长、团长、团长、营长、营长、连长、连长、连长、排长、排长、排长、工、工、工、雷、雷、雷、炸、炸、军旗\n        var chess_array = [_chess__WEBPACK_IMPORTED_MODULE_0__.Rank.FieldMarshal, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.General, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.MajorGeneral, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.MajorGeneral,\n            _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Brigadier, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Brigadier, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Colonel, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Colonel, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Major, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Major,\n            _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Captain, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Captain, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Captain, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Lieutenant, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Lieutenant, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Lieutenant,\n            _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Engineer, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Engineer, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Engineer, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Landmine, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Landmine, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Landmine,\n            _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Bomb, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Bomb, _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Flag];\n        chess_array.forEach(function (rank) {\n            _this.chessList.push(new _chess__WEBPACK_IMPORTED_MODULE_0__.Chess(rank, address));\n            _this.chessList.push(new _chess__WEBPACK_IMPORTED_MODULE_0__.Chess(_chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Empty, oppAddress));\n        });\n    };\n    Board.prototype.initLocationEdges = function () {\n        var _this = this;\n        for (var x = 0; x < this.columnCnt; x++) {\n            //添加左右相邻位置的location\n            if (x <= 3) {\n                for (var y = 0; y < this.rowCnt; y++) {\n                    this.addEdge(this.getLocationInstance(x, y), this.getLocationInstance(x + 1, y));\n                }\n            }\n            //添加play1上下相邻的location、play2上下相邻的location \n            for (var y = 0; y <= 4; y++) { //cols\n                this.addEdge(this.getLocationInstance(x, y), this.getLocationInstance(x, y + 1));\n            }\n            for (var y = 6; y <= 10; y++) { //cols\n                this.addEdge(this.getLocationInstance(x, y), this.getLocationInstance(x, y + 1));\n            }\n        }\n        //前线周边位置添加\n        this.addEdge(this.getLocationInstance(0, 5), this.getLocationInstance(0, 6));\n        this.addEdge(this.getLocationInstance(2, 5), this.getLocationInstance(2, 6));\n        this.addEdge(this.getLocationInstance(4, 5), this.getLocationInstance(4, 6));\n        //foreach camp\n        this.locations.forEach(function (location) {\n            if (location.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n                _this.addEdge(location, _this.getLocationInstance(location.x - 1, location.y - 1));\n                _this.addEdge(location, _this.getLocationInstance(location.x - 1, location.y + 1));\n                _this.addEdge(location, _this.getLocationInstance(location.x + 1, location.y - 1));\n                _this.addEdge(location, _this.getLocationInstance(location.x + 1, location.y + 1));\n            }\n        });\n    };\n    //关联两个相邻位置\n    Board.prototype.addEdge = function (location1, location2) {\n        location1.addEdge(location2);\n        location2.addEdge(location1);\n    };\n    // After Field Marshal died, the flag will be reveal \n    Board.prototype.RevealFlag = function (address) {\n        this.GetChessList(address, false).forEach(function (chess) {\n            if (chess.rank == _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Flag) {\n                chess.displayed = true;\n            }\n        });\n    };\n    Board.prototype.getFlagLocation = function (address) {\n        for (var _i = 0, _a = this.locations; _i < _a.length; _i++) {\n            var location_1 = _a[_i];\n            if (location_1.getChess() && location_1.getChess().rank == _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Flag && location_1.getChess().address == address) {\n                return location_1;\n            }\n        }\n    };\n    Board.prototype.destroy_chess = function (chess) {\n        if (chess.rank == _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Flag) {\n            GameOver(chess.address);\n        }\n        //RevealFlag when Field Marshal is destroyed\n        if (chess.rank == _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.FieldMarshal) {\n            this.RevealFlag(chess.address);\n        }\n        chess.chessStatus = _chess__WEBPACK_IMPORTED_MODULE_0__.ChessStatus.Captured;\n    };\n    // Get the location of a chess\n    Board.prototype.GetChessLocation = function (chess) {\n        for (var _i = 0, _a = this.locations; _i < _a.length; _i++) {\n            var location_2 = _a[_i];\n            if (location_2.getChess() == chess) {\n                return location_2;\n            }\n        }\n        console.log(\"error GetChessLocation not find chess:\", chess.rank);\n        return undefined;\n    };\n    // Return a list of chess for that player.\n    // All the chess belongs to the player will be returned,\n    // no matter died or alive.\n    Board.prototype.GetChessList = function (address, OnBoard) {\n        if (OnBoard === void 0) { OnBoard = false; }\n        var chessList = [];\n        for (var _i = 0, _a = this.chessList; _i < _a.length; _i++) {\n            var chess = _a[_i];\n            if (chess.address != address) {\n                continue;\n            }\n            if (OnBoard) {\n                if (chess.chessStatus == _chess__WEBPACK_IMPORTED_MODULE_0__.ChessStatus.OnBoard) {\n                    chessList.push(chess);\n                }\n            }\n            else {\n                chessList.push(chess);\n            }\n        }\n        return chessList;\n    };\n    // Find the location instance with same (x,y)\n    Board.prototype.getLocationInstance = function (x, y) {\n        for (var _i = 0, _a = this.locations; _i < _a.length; _i++) {\n            var location_3 = _a[_i];\n            if (location_3.x == x && location_3.y == y) {\n                return location_3;\n            }\n        }\n        return new _location__WEBPACK_IMPORTED_MODULE_1__.Location(x, y, _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Headquarters, this.isOnRail(x, y));\n    };\n    Board.prototype.getPlayableLocation = function (x, chess, locations) {\n        for (var y = 6; y < this.rowCnt; y++) {\n            var tmp = this.getLocationInstance(x, y);\n            //行营不能放置 \n            if (tmp.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n                continue;\n            }\n            switch (chess.rank) {\n                case _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Flag: //大本营\n                    if (tmp.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Headquarters) {\n                        locations.push(this.getLocationInstance(x, y));\n                    }\n                    break;\n                case _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Bomb: //炸弹只能放在次2行\n                    if (y >= 7) {\n                        locations.push(this.getLocationInstance(x, y));\n                    }\n                    break;\n                case _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Landmine: //\n                    if (y >= 10) {\n                        locations.push(this.getLocationInstance(x, y));\n                    }\n                    break;\n                default:\n                    locations.push(this.getLocationInstance(x, y));\n                    break;\n            }\n        }\n    };\n    Board.prototype.GetPlaceableLocation = function (oriLocation) {\n        var tmpLoc = [];\n        var chess = oriLocation.getChess();\n        if (!chess) {\n            return tmpLoc;\n        }\n        for (var x = 0; x < this.columnCnt; x++) {\n            this.getPlayableLocation(x, chess, tmpLoc);\n        }\n        return tmpLoc;\n    };\n    Board.prototype.swap = function (oriLocation, targetLocation) {\n        var oriChess = oriLocation.getChess();\n        var targetChess = targetLocation.getChess();\n        if (this.GetPlaceableLocation(oriLocation).indexOf(targetLocation) != -1 &&\n            this.GetPlaceableLocation(targetLocation).indexOf(oriLocation) != -1) {\n            oriLocation.setChess(targetChess);\n            targetLocation.setChess(oriChess);\n        }\n    };\n    // List the movable location for a chess on a particular location\n    Board.prototype.GetMovableLocation = function (oriLocation) {\n        var _a;\n        var queue = [];\n        var visited = [];\n        var movable = [];\n        if (((_a = oriLocation.getChess()) === null || _a === void 0 ? void 0 : _a.rank) == _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Landmine || oriLocation.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Headquarters) {\n            return [];\n        }\n        visited.push(oriLocation);\n        oriLocation.edges.forEach(function (location) { return queue.push(location); });\n        while (queue.length > 0) {\n            var targetLocation = queue.shift();\n            visited.push(targetLocation);\n            var _b = is_movable(oriLocation, targetLocation), movable1 = _b[0], movable2 = _b[1];\n            if (movable1) {\n                movable.push(targetLocation);\n            }\n            if (!movable2) {\n                continue;\n            }\n            targetLocation.edges.forEach(function (location) {\n                if (location.isOnRail == true) {\n                    var visited_bool = false;\n                    for (var _i = 0, visited_1 = visited; _i < visited_1.length; _i++) {\n                        var visitedLocation = visited_1[_i];\n                        if (visitedLocation == location) {\n                            visited_bool = true;\n                            break;\n                        }\n                    }\n                    // if visited -> skip\n                    if (!visited_bool && queue.indexOf(location) == -1)\n                        queue.push(location);\n                }\n            });\n        }\n        return movable;\n    };\n    Board.prototype.isFlagLocation = function (x, y) {\n        if ((y == 0 || y == 11) && (x == 1 || x == 3)) {\n            return true;\n        }\n        return false;\n    };\n    Board.prototype.isOnRail = function (x, y) {\n        //第一行和最后一行\n        if (y == 0 || y == 11) {\n            return false;\n        }\n        if (y == 1 || y == 5 || y == 6 || y == 10) {\n            return true;\n        }\n        if (y == 2 || y == 3 || y == 4 || y == 7 || y == 8) {\n            if (x == 0 || x == 4) {\n                return true;\n            }\n            return false;\n        }\n        return false;\n    };\n    //设置location type\n    Board.prototype.setLocationType = function (y) {\n        for (var x = 0; x < this.columnCnt; x++) {\n            var locationType = _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.SoldierStation;\n            //第0行1列或者1行4列是大本营的位置 第12行1列或者12行4列也是大本营的位置\n            if ((x == 1 && (y == 0 || y == 11)) || (x == 3 && (y == 0 || y == 11))) {\n                locationType = _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Headquarters;\n            }\n            //行营\n            if (((x == 1 || x == 3) && (y == 2 || y == 4 || y == 7 || y == 9))\n                || (x == 2 && (y == 3 || y == 8))) {\n                locationType = _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp;\n            }\n            this.locations.push(new _location__WEBPACK_IMPORTED_MODULE_1__.Location(x, y, locationType, this.isOnRail(x, y)));\n        }\n    };\n    return Board;\n}());\n\nfunction is_movable(oriLocation, targetLocation) {\n    var enemyChess = -1; //no ches\n    if (targetLocation.getChess() && targetLocation.getChess().address != oriLocation.getChess().address) {\n        enemyChess = 1; //enemy chess\n    }\n    //我方棋子\n    if (targetLocation.getChess() && targetLocation.getChess().address == oriLocation.getChess().address) {\n        enemyChess = 0; //our chess\n    }\n    //for direct linkage 不是在铁路上但是位置相邻\n    if (!oriLocation.isOnRail && oriLocation.edges.indexOf(targetLocation) != -1) {\n        if (enemyChess == 0) {\n            return [false, false];\n        }\n        //目标位置对方棋子，且目标位置类型是行营\n        if (enemyChess == 1 && targetLocation.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n            return [false, false];\n        }\n        return [true, false];\n    }\n    //for rail case 工兵\n    var engineer = false;\n    if (oriLocation.getChess() && oriLocation.getChess().rank == _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Engineer) {\n        engineer = true;\n    }\n    //位置相邻\n    if (oriLocation.edges.indexOf(targetLocation) > -1) {\n        if (enemyChess == 0) {\n            return [false, false];\n        }\n        if (enemyChess == 1 && targetLocation.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n            return [false, false];\n        }\n        if (enemyChess == 1 && targetLocation.locationType != _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n            return [true, false];\n        }\n        if (targetLocation.isOnRail == false) {\n            return [true, false];\n        }\n        return [true, true];\n    }\n    if (enemyChess == 0) {\n        return [false, false];\n    }\n    if (enemyChess == 1 && targetLocation.locationType == _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n        return [false, false];\n    }\n    if (targetLocation.isOnRail == false) {\n        return [false, false];\n    }\n    if (engineer) {\n        if (enemyChess == 1 && targetLocation.locationType != _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp) {\n            return [true, false];\n        }\n        return [true, true];\n    }\n    else {\n        if (enemyChess == 1 && targetLocation.locationType != _location__WEBPACK_IMPORTED_MODULE_1__.LocationType.Camp &&\n            (oriLocation.x == targetLocation.x || oriLocation.y == targetLocation.y)) {\n            return [true, false];\n        }\n        if (targetLocation.isOnRail == true && (oriLocation.x == targetLocation.x || oriLocation.y == targetLocation.y)) {\n            return [true, true];\n        }\n        else {\n            return [false, false];\n        }\n    }\n}\nfunction GameOver(address) {\n    alert(\"Player\" + address + \"Won!\");\n}\n\n\n//# sourceURL=webpack://www/./src/board.ts?");

/***/ }),

/***/ "./src/chess.ts":
/*!**********************!*\
  !*** ./src/chess.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chess: () => (/* binding */ Chess),\n/* harmony export */   ChessStatus: () => (/* binding */ ChessStatus),\n/* harmony export */   RANK_ZH: () => (/* binding */ RANK_ZH),\n/* harmony export */   Rank: () => (/* binding */ Rank)\n/* harmony export */ });\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game */ \"./src/game.ts\");\n/* harmony import */ var _login__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./login */ \"./src/login.ts\");\n//==============================================================================\n// Chess\n//==============================================================================\n\n\nvar RANK_ZH = [\n    \"空\",\n    \"军旗\",\n    \"炸弹\",\n    \"地雷\",\n    \"工兵\",\n    \"排长\",\n    \"连长\",\n    \"营长\",\n    \"团长\",\n    \"旅长\",\n    \"师长\",\n    \"军长\",\n    \"司令\"\n];\nvar Rank;\n(function (Rank) {\n    Rank[Rank[\"Empty\"] = 0] = \"Empty\";\n    Rank[Rank[\"Flag\"] = 1] = \"Flag\";\n    Rank[Rank[\"Bomb\"] = 2] = \"Bomb\";\n    Rank[Rank[\"Landmine\"] = 3] = \"Landmine\";\n    Rank[Rank[\"Engineer\"] = 4] = \"Engineer\";\n    Rank[Rank[\"Lieutenant\"] = 5] = \"Lieutenant\";\n    Rank[Rank[\"Captain\"] = 6] = \"Captain\";\n    Rank[Rank[\"Major\"] = 7] = \"Major\";\n    Rank[Rank[\"Colonel\"] = 8] = \"Colonel\";\n    Rank[Rank[\"Brigadier\"] = 9] = \"Brigadier\";\n    Rank[Rank[\"MajorGeneral\"] = 10] = \"MajorGeneral\";\n    Rank[Rank[\"General\"] = 11] = \"General\";\n    Rank[Rank[\"FieldMarshal\"] = 12] = \"FieldMarshal\";\n    Rank[Rank[\"Unchanged\"] = 13] = \"Unchanged\";\n    Rank[Rank[\"Opponent\"] = 14] = \"Opponent\";\n})(Rank || (Rank = {}));\n//棋子状态\nvar ChessStatus;\n(function (ChessStatus) {\n    ChessStatus[ChessStatus[\"OnBoard\"] = 1] = \"OnBoard\";\n    ChessStatus[ChessStatus[\"Captured\"] = 2] = \"Captured\";\n})(ChessStatus || (ChessStatus = {}));\n// Chess object representing a chess instance\nvar Chess = /** @class */ (function () {\n    function Chess(rank, address) {\n        this.rank = rank;\n        this.chessStatus = ChessStatus.OnBoard;\n        this.displayed = false;\n        this.address = address;\n    }\n    Chess.prototype.isLocalChess = function () {\n        return this.address == _game__WEBPACK_IMPORTED_MODULE_0__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_1__.gameId).getLocalAddresses();\n    };\n    return Chess;\n}());\n\n\n\n//# sourceURL=webpack://www/./src/chess.ts?");

/***/ }),

/***/ "./src/draw.ts":
/*!*********************!*\
  !*** ./src/draw.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   draw: () => (/* binding */ draw),\n/* harmony export */   drawChess: () => (/* binding */ drawChess),\n/* harmony export */   draw_array: () => (/* binding */ draw_array),\n/* harmony export */   getDrawPos: () => (/* binding */ getDrawPos),\n/* harmony export */   getDrawPosIndex: () => (/* binding */ getDrawPosIndex),\n/* harmony export */   getRectObj: () => (/* binding */ getRectObj),\n/* harmony export */   initDraw: () => (/* binding */ initDraw),\n/* harmony export */   resetChess: () => (/* binding */ resetChess),\n/* harmony export */   updateShowMessage: () => (/* binding */ updateShowMessage)\n/* harmony export */ });\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event */ \"./src/event.ts\");\n/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ \"./src/init.ts\");\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./main */ \"./src/main.ts\");\n\n\n\nvar draw_array = [];\nfunction updateShowMessage(text) {\n    var waitingMessage = document.getElementById(\"showMessage\");\n    waitingMessage.textContent = text;\n}\n//根据xy坐标获取元素\nfunction getDrawPos(x, y) {\n    return _init__WEBPACK_IMPORTED_MODULE_1__.draw_pos[x + y * 5];\n}\n//获取x、y坐标\nfunction getDrawPosIndex(obj) {\n    var index = _init__WEBPACK_IMPORTED_MODULE_1__.draw_pos.indexOf(obj);\n    if (index === -1) {\n        return undefined;\n    }\n    return { x: index % 5, y: Math.floor(index / 5) };\n}\n//给定的坐标 coordinate 来查找 draw_pos 数组中符合条件的矩形对象\nfunction getRectObj(coordinate) {\n    var canvasX = coordinate.x;\n    var canvasY = coordinate.y;\n    var inside;\n    // 遍历draw_pos数组，查找符合条件的元素\n    _init__WEBPACK_IMPORTED_MODULE_1__.draw_pos.forEach(function (i) {\n        if (i.x <= canvasX && canvasX <= i.x + _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH && i.y <= canvasY && canvasY <= i.y + _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT) {\n            inside = i;\n        }\n    });\n    return inside;\n}\nfunction resetChess() {\n    draw_array = [];\n}\nfunction drawChess(txt, x, y, color, txt_visible, bgColor) {\n    draw_array.push({ txt: txt, x: x, y: y, color: color, txt_visible: txt_visible, bgColor: bgColor });\n}\nvar dash_count = 0;\nvar loop_count = 0;\nfunction initDraw() {\n    dash_count = 0;\n    loop_count = 0;\n}\n/**\n * 绘制函数\n * @param ctx 画布上下文\n */\nfunction draw(ctx) {\n    // 清除画布\n    ctx.clearRect(0, 0, _init__WEBPACK_IMPORTED_MODULE_1__.canvas.width, _init__WEBPACK_IMPORTED_MODULE_1__.canvas.height);\n    // 绘制矩形框\n    drawRectangles(ctx);\n    // 绘制虚线框\n    drawDottedRectangles(ctx);\n    // 绘制文本\n    drawText(ctx);\n}\n/**\n * 绘制虚线框\n * @param ctx 画布上下文\n */\nfunction drawDottedRectangles(ctx) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.setLineDash([]);\n    ctx.lineDashOffset = dash_count;\n    _event__WEBPACK_IMPORTED_MODULE_0__.selected_chess_movable.forEach(function (item) {\n        ctx.lineWidth = 3;\n        var alpha = 1 * Math.abs(loop_count - 150) / 150;\n        ctx.strokeStyle = \"rgba(0, 200, 0, \".concat(alpha, \")\");\n        ctx.strokeRect(item.x, item.y, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT);\n    });\n    ctx.stroke();\n    ctx.closePath();\n    ctx.restore();\n}\n/**\n * 绘制矩形框\n * @param ctx 画布上下文\n */\nfunction drawRectangles(ctx) {\n    draw_array.forEach(function (item) {\n        ctx.save();\n        ctx.beginPath();\n        var drawPos = getDrawPos(item.x, item.y);\n        var isSelectedChess = drawPos === _event__WEBPACK_IMPORTED_MODULE_0__.selected_chess;\n        ctx.lineWidth = 2;\n        if (isSelectedChess) {\n            ctx.strokeStyle = \"orange\";\n            if (_event__WEBPACK_IMPORTED_MODULE_0__.mouse_down) {\n                var offsetX = drawPos.x + (_event__WEBPACK_IMPORTED_MODULE_0__.mouse_current_pos.x - _event__WEBPACK_IMPORTED_MODULE_0__.mouse_start_pos.x);\n                var offsetY = drawPos.y + (_event__WEBPACK_IMPORTED_MODULE_0__.mouse_current_pos.y - _event__WEBPACK_IMPORTED_MODULE_0__.mouse_start_pos.y);\n                ctx.rect(offsetX, offsetY, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT);\n            }\n            else {\n                ctx.rect(drawPos.x, drawPos.y, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT);\n            }\n        }\n        else {\n            ctx.setLineDash([]);\n            ctx.strokeStyle = item.color;\n            ctx.rect(drawPos.x, drawPos.y, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT);\n        }\n        ctx.fillStyle = isSelectedChess ? \"lightblue\" : item.bgColor;\n        ctx.fill();\n        ctx.stroke();\n        ctx.closePath();\n        ctx.restore();\n    });\n}\n/**\n * 绘制文本\n * @param ctx 画布上下文\n */\nfunction drawText(ctx) {\n    ctx.font = '20px arial';\n    ctx.textAlign = \"left\";\n    draw_array.forEach(function (item) {\n        var debugCheckbox = document.getElementById(\"debug\");\n        if (!debugCheckbox.checked && !item.txt_visible) {\n            return;\n        }\n        ctx.save();\n        ctx.beginPath();\n        var drawPos = getDrawPos(item.x, item.y);\n        var isSelectedChess = drawPos === _event__WEBPACK_IMPORTED_MODULE_0__.selected_chess;\n        if (isSelectedChess && _event__WEBPACK_IMPORTED_MODULE_0__.mouse_down) {\n            var offsetX = drawPos.x + (_event__WEBPACK_IMPORTED_MODULE_0__.mouse_current_pos.x - _event__WEBPACK_IMPORTED_MODULE_0__.mouse_start_pos.x);\n            var offsetY = drawPos.y + (_event__WEBPACK_IMPORTED_MODULE_0__.mouse_current_pos.y - _event__WEBPACK_IMPORTED_MODULE_0__.mouse_start_pos.y);\n            var gradient = ctx.createLinearGradient(offsetX, offsetY, offsetX + _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH, offsetY + _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT);\n            gradient.addColorStop(0, \"white\"); // 起始颜色\n            gradient.addColorStop(1, item.color); // 结束颜色，可根据棋子颜色调整\n            ctx.fillStyle = gradient;\n            ctx.rect(offsetX, offsetY, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH, _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT);\n            ctx.fill();\n            ctx.fillText(item.txt, offsetX + 9, offsetY + 25);\n        }\n        else {\n            var gradient = ctx.createLinearGradient(drawPos.x, drawPos.y, drawPos.x + _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_WIDTH, drawPos.y + _main__WEBPACK_IMPORTED_MODULE_2__.CHESS_HEIGHT);\n            gradient.addColorStop(0, \"white\"); // 起始颜色\n            gradient.addColorStop(1, item.color); // 结束颜色，可根据棋子颜色调整\n            ctx.fillStyle = gradient;\n            ctx.fillText(item.txt, drawPos.x + 9, drawPos.y + 25);\n        }\n        ctx.closePath();\n        ctx.restore();\n    });\n}\n\n\n//# sourceURL=webpack://www/./src/draw.ts?");

/***/ }),

/***/ "./src/event.ts":
/*!**********************!*\
  !*** ./src/event.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   board: () => (/* binding */ board),\n/* harmony export */   canvasDown: () => (/* binding */ canvasDown),\n/* harmony export */   canvasMousemove: () => (/* binding */ canvasMousemove),\n/* harmony export */   canvasUp: () => (/* binding */ canvasUp),\n/* harmony export */   clearSelectChess: () => (/* binding */ clearSelectChess),\n/* harmony export */   handleGameStart: () => (/* binding */ handleGameStart),\n/* harmony export */   handleMoveResult: () => (/* binding */ handleMoveResult),\n/* harmony export */   handlePiecePosEvent: () => (/* binding */ handlePiecePosEvent),\n/* harmony export */   handleRole: () => (/* binding */ handleRole),\n/* harmony export */   initEventsValue: () => (/* binding */ initEventsValue),\n/* harmony export */   mouse_current_pos: () => (/* binding */ mouse_current_pos),\n/* harmony export */   mouse_down: () => (/* binding */ mouse_down),\n/* harmony export */   mouse_start_pos: () => (/* binding */ mouse_start_pos),\n/* harmony export */   selected_chess: () => (/* binding */ selected_chess),\n/* harmony export */   selected_chess_movable: () => (/* binding */ selected_chess_movable),\n/* harmony export */   stepNextMove: () => (/* binding */ stepNextMove)\n/* harmony export */ });\n/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw */ \"./src/draw.ts\");\n/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init */ \"./src/init.ts\");\n/* harmony import */ var _login__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./login */ \"./src/login.ts\");\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./main */ \"./src/main.ts\");\n/* harmony import */ var _board__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./board */ \"./src/board.ts\");\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./game */ \"./src/game.ts\");\n/* harmony import */ var _chess__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chess */ \"./src/chess.ts\");\n/* harmony import */ var _location__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./location */ \"./src/location.ts\");\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./player */ \"./src/player.ts\");\n/* harmony import */ var _aleo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./aleo */ \"./src/aleo.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n\n\n\n\n\n\n// const assert = require('assert');\nvar mouse_down = false;\nvar mouse_start_pos;\nvar mouse_current_pos;\nvar selected_chess; // draw_pos\nvar selected_chess_movable = [];\nfunction clearSelectChess() {\n    selected_chess = null;\n    selected_chess_movable = [];\n}\nfunction initEventsValue() {\n    mouse_down = false;\n    mouse_start_pos = undefined;\n    mouse_current_pos = undefined;\n    selected_chess = undefined;\n    selected_chess_movable = [];\n}\nfunction judgeStateUnSelect() {\n    var state = _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getGameState();\n    if (state == _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_GAME_START || state == _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_MOVABLE_RESULT || state == _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_MOVEABLE) {\n        return true;\n    }\n}\nfunction clickChessHandler(chess, coords, logicCoords) {\n    playClickSound().then(function () {\n        if (!chess.isLocalChess()) {\n            console.log(\"player is not right chessPlay:\", chess.address);\n            return;\n        }\n        selected_chess = coords;\n        selected_chess_movable = [];\n        var gameState = _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getGameState();\n        var curLocation = board.getLocationInstance(logicCoords.x, logicCoords.y);\n        if (gameState === _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_READY) {\n            handleWaitingReadyState(curLocation);\n        }\n        if (gameState === _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.MOVABLE) {\n            handleMovableState(curLocation);\n        }\n    })\n        .catch(function (error) {\n        console.error(\"Failed to play click sound:\", error);\n    });\n}\nfunction playClickSound() {\n    return __awaiter(this, void 0, void 0, function () {\n        var audio;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    audio = new Audio(\"../images/mouseClick.mp3\");\n                    return [4 /*yield*/, audio.play()];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction handleWaitingReadyState(curLocation) {\n    var movable_location = board.GetPlaceableLocation(curLocation);\n    for (var _i = 0, movable_location_1 = movable_location; _i < movable_location_1.length; _i++) {\n        var location_1 = movable_location_1[_i];\n        if (board.GetPlaceableLocation(location_1).indexOf(curLocation) > -1) {\n            selected_chess_movable.push((0,_draw__WEBPACK_IMPORTED_MODULE_0__.getDrawPos)(location_1.x, location_1.y));\n        }\n    }\n}\nfunction handleMovableState(curLocation) {\n    var movable_location = board.GetMovableLocation(curLocation);\n    movable_location.forEach(function (i) {\n        selected_chess_movable.push((0,_draw__WEBPACK_IMPORTED_MODULE_0__.getDrawPos)(i.x, i.y));\n    });\n}\n//鼠标点击事件\nfunction canvasDown(e) {\n    mouse_down = true;\n    mouse_start_pos = { x: e.offsetX, y: e.offsetY };\n    mouse_current_pos = { x: e.offsetX, y: e.offsetY };\n    if (judgeStateUnSelect()) {\n        return;\n    }\n    var coords = (0,_draw__WEBPACK_IMPORTED_MODULE_0__.getRectObj)(mouse_start_pos);\n    if (!coords) {\n        console.log(\"coords is undefined\", coords);\n        return;\n    }\n    var logicCoords = (0,_draw__WEBPACK_IMPORTED_MODULE_0__.getDrawPosIndex)(coords);\n    if (!logicCoords) {\n        return;\n    }\n    var chess = board.getLocationInstance(logicCoords.x, logicCoords.y).getChess();\n    if (!chess) {\n        return;\n    }\n    if (chess.address != _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getLocalAddresses()) {\n        return;\n    }\n    clickChessHandler(chess, coords, logicCoords);\n}\nfunction canvasUp(e) {\n    return __awaiter(this, void 0, void 0, function () {\n        var rect_obj, gameState, oriPos, targetPos, oriLocation, chess, targetLocation;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    mouse_start_pos = null;\n                    mouse_current_pos = { x: e.offsetX, y: e.offsetY };\n                    mouse_down = false;\n                    rect_obj = (0,_draw__WEBPACK_IMPORTED_MODULE_0__.getRectObj)(mouse_current_pos);\n                    gameState = _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getGameState();\n                    if (gameState === _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_MOVABLE_RESULT) {\n                        return [2 /*return*/];\n                    }\n                    if (!(rect_obj && selected_chess)) return [3 /*break*/, 3];\n                    oriPos = (0,_draw__WEBPACK_IMPORTED_MODULE_0__.getDrawPosIndex)(selected_chess);\n                    targetPos = (0,_draw__WEBPACK_IMPORTED_MODULE_0__.getDrawPosIndex)(rect_obj);\n                    if (!oriPos || !targetPos) {\n                        return [2 /*return*/];\n                    }\n                    if (oriPos.x == targetPos.x && oriPos.y == targetPos.y) {\n                        return [2 /*return*/];\n                    }\n                    oriLocation = board.getLocationInstance(oriPos.x, oriPos.y);\n                    chess = oriLocation.getChess();\n                    if (!chess || !chess.isLocalChess()) {\n                        return [2 /*return*/];\n                    }\n                    targetLocation = board.getLocationInstance(targetPos.x, targetPos.y);\n                    if (!(gameState === _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_READY)) return [3 /*break*/, 1];\n                    canvasHandleWaitingReadyState(oriLocation, targetLocation);\n                    return [3 /*break*/, 3];\n                case 1: return [4 /*yield*/, canvasHandleMoveEventState(chess, oriPos, targetLocation)];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3:\n                    (0,_main__WEBPACK_IMPORTED_MODULE_3__.updateDrawArray)();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction canvasHandleWaitingReadyState(oriLocation, targetLocation) {\n    board.swap(oriLocation, targetLocation);\n    selected_chess = null;\n    selected_chess_movable = [];\n}\nfunction canvasHandleMoveEventState(chess, oriPos, targetLocation) {\n    return __awaiter(this, void 0, void 0, function () {\n        var flagLocation;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (chess.rank == _chess__WEBPACK_IMPORTED_MODULE_6__.Rank.FieldMarshal) {\n                        flagLocation = board.getFlagLocation(_game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getLocalAddresses());\n                        _login__WEBPACK_IMPORTED_MODULE_2__.ws.sendMoveEvent(chess.rank, oriPos.x, oriPos.y, targetLocation.x, targetLocation.y, flagLocation.x, flagLocation.y);\n                    }\n                    else {\n                        _login__WEBPACK_IMPORTED_MODULE_2__.ws.sendMoveEvent(chess.rank, oriPos.x, oriPos.y, targetLocation.x, targetLocation.y);\n                    }\n                    _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).setGameState(_game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_MOVABLE_RESULT);\n                    //等待上链\n                    return [4 /*yield*/, (0,_aleo__WEBPACK_IMPORTED_MODULE_9__.aleoMovePiece)(oriPos.x, oriPos.y, targetLocation.x, targetLocation.y)];\n                case 1:\n                    //等待上链\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction canvasMousemove(e) {\n    if (mouse_down) {\n        mouse_current_pos = { x: e.offsetX, y: e.offsetY };\n    }\n}\nvar board;\n//处理ws通知对手匹配完成事件\nfunction handleRole(data) {\n    var game = _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(data.game_id);\n    if (game != undefined) {\n        console.log(\"handleRole game exist id:\", data.game_id);\n        return;\n    }\n    var oppAddress = data.player1 == _login__WEBPACK_IMPORTED_MODULE_2__.account.toString() ? data.player2 : data.player1;\n    _game__WEBPACK_IMPORTED_MODULE_5__.Game.createInstance(data.game_id, data.player1, data.player2, _login__WEBPACK_IMPORTED_MODULE_2__.account, data.arbiter);\n    board = new _board__WEBPACK_IMPORTED_MODULE_4__.Board(_login__WEBPACK_IMPORTED_MODULE_2__.account, oppAddress);\n    (0,_init__WEBPACK_IMPORTED_MODULE_1__.drawBoardInit)(_login__WEBPACK_IMPORTED_MODULE_2__.account.toString(), oppAddress);\n    (0,_login__WEBPACK_IMPORTED_MODULE_2__.changeDisplay)();\n    _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).setGameState(_game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_READY);\n}\n//双方都ready，game start\nfunction handleGameStart(data) {\n    var game = _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(data.game_id);\n    if (game == undefined) {\n        console.log(\"handleGameStart game not exist id:\", data.game_id);\n        return;\n    }\n    var stopButton = document.getElementById(\"timerShow\");\n    stopButton.style.visibility = \"visible\";\n    if (data.turn == _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getLocalAddresses()) {\n        console.log(\"handleGameStart waiting move chess\");\n        _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).setGameState(_game__WEBPACK_IMPORTED_MODULE_5__.EGameState.MOVABLE);\n        (0,_draw__WEBPACK_IMPORTED_MODULE_0__.updateShowMessage)(\"move the piece\");\n    }\n    else {\n        console.log(\"game start and player2 waiting moveable\");\n        _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).setGameState(_game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_MOVEABLE);\n        (0,_draw__WEBPACK_IMPORTED_MODULE_0__.updateShowMessage)(\"opponent move the piece\");\n    }\n}\nfunction handlePiecePosEvent(data) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, reX, reY, targetChess, flagLocation;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _a = (0,_location__WEBPACK_IMPORTED_MODULE_7__.getRevertLocation)(data.target_x, data.target_y), reX = _a[0], reY = _a[1];\n                    targetChess = board.getLocationInstance(reX, reY).getChess();\n                    if (!(targetChess == null)) return [3 /*break*/, 2];\n                    return [4 /*yield*/, _login__WEBPACK_IMPORTED_MODULE_2__.ws.sendWhisperEvent(0, data.target_x, data.target_y)];\n                case 1:\n                    _b.sent();\n                    return [2 /*return*/];\n                case 2:\n                    if (targetChess.address != _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getLocalAddresses()) {\n                        console.log(\"handlePiecePosEvent error target is not owner chess:(x:\".concat(data.target_x, \", y:\").concat(data.target_y, \") revert:(x:\").concat(reX, \", y:\").concat(reY, \")\"));\n                    }\n                    // assert(targetChess.address == game.getCurrentAccount().toString())\n                    return [4 /*yield*/, (0,_aleo__WEBPACK_IMPORTED_MODULE_9__.aleoWhisperPiece)(reX, reY)];\n                case 3:\n                    // assert(targetChess.address == game.getCurrentAccount().toString())\n                    _b.sent();\n                    if (!(targetChess.rank == _chess__WEBPACK_IMPORTED_MODULE_6__.Rank.FieldMarshal)) return [3 /*break*/, 5];\n                    flagLocation = board.getFlagLocation(_game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getLocalAddresses());\n                    return [4 /*yield*/, _login__WEBPACK_IMPORTED_MODULE_2__.ws.sendWhisperEvent(targetChess.rank, data.target_x, data.target_y, flagLocation.x, flagLocation.y)];\n                case 4:\n                    _b.sent();\n                    return [3 /*break*/, 7];\n                case 5: \n                //发送棋子信息\n                return [4 /*yield*/, _login__WEBPACK_IMPORTED_MODULE_2__.ws.sendWhisperEvent(targetChess.rank, data.target_x, data.target_y)];\n                case 6:\n                    //发送棋子信息\n                    _b.sent();\n                    _b.label = 7;\n                case 7: return [2 /*return*/];\n            }\n        });\n    });\n}\nvar AttackResult;\n(function (AttackResult) {\n    AttackResult[AttackResult[\"SimpleMove\"] = 0] = \"SimpleMove\";\n    AttackResult[AttackResult[\"Win\"] = 1] = \"Win\";\n    AttackResult[AttackResult[\"Draw\"] = 2] = \"Draw\";\n    AttackResult[AttackResult[\"Lose\"] = 3] = \"Lose\";\n})(AttackResult || (AttackResult = {}));\n//不是行走棋子方，需要转坐标\nfunction getPositions(data) {\n    if (_game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getGameState() != _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_MOVABLE_RESULT) {\n        var _a = (0,_location__WEBPACK_IMPORTED_MODULE_7__.getRevertLocation)(data.x, data.y), revert_X = _a[0], revert_Y = _a[1];\n        var _b = (0,_location__WEBPACK_IMPORTED_MODULE_7__.getRevertLocation)(data.target_x, data.target_y), revert_X1 = _b[0], revert_Y1 = _b[1];\n        return [revert_X, revert_Y, revert_X1, revert_Y1];\n    }\n    return [data.x, data.y, data.target_x, data.target_y];\n}\nfunction updateMoveResult(x, y, targetX, targetY, attackResult, game_winner, flag_x, flag_y, opp_flag_x, opp_flag_y) {\n    var _a, _b;\n    if (game_winner === void 0) { game_winner = 0; }\n    var flagX = 5;\n    var flagY = 0;\n    var oppFlagX = 5;\n    var oppFlagY = 0;\n    if (game_winner)\n        if (board.isFlagLocation(flag_x, flag_y)) {\n            _a = (0,_location__WEBPACK_IMPORTED_MODULE_7__.getRevertLocation)(flag_x, flag_y), flagX = _a[0], flagY = _a[1];\n        }\n    if (board.isFlagLocation(opp_flag_x, opp_flag_y)) {\n        _b = (0,_location__WEBPACK_IMPORTED_MODULE_7__.getRevertLocation)(opp_flag_x, opp_flag_y), oppFlagX = _b[0], oppFlagY = _b[1];\n    }\n    (0,_aleo__WEBPACK_IMPORTED_MODULE_9__.updateMoveInfo)(_login__WEBPACK_IMPORTED_MODULE_2__.gameId, x, y, targetX, targetY, attackResult, flag_x, flag_y, oppFlagX, oppFlagY, game_winner);\n}\n//处理move result结果\nfunction handleMoveResult(data) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, origX, origY, targetX, targetY, state;\n        return __generator(this, function (_b) {\n            _a = getPositions(data), origX = _a[0], origY = _a[1], targetX = _a[2], targetY = _a[3];\n            state = _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getGameState();\n            updateMoveResult(origX, origY, targetX, targetY, data.AttackResult, data.game_winner, data.flag_x, data.flag_y, data.opp_flag_x, data.opp_flag_y);\n            switch (data.attack_result) {\n                case AttackResult.SimpleMove:\n                    handleSimpleMoveResult(origX, origY, targetX, targetY);\n                    break;\n                case AttackResult.Win:\n                    handleWinMoveResult(origX, origY, targetX, targetY, data.opp_flag_x, data.opp_flag_y);\n                    break;\n                case AttackResult.Draw:\n                    handleDrawMoveEvent(origX, origY, targetX, targetY, data.flag_x, data.flag_y, data.opp_flag_x, data.opp_flag_y);\n                    break;\n                case AttackResult.Lose:\n                    handleLoseMoveEvent(origX, origY, data.flag_x, data.flag_y, data.opp_flag_x, data.opp_flag_y);\n                    break;\n                default:\n                    console.log(\"error event\", data.AttackResult);\n            }\n            stepNextMove(state);\n            if (data.game_winner == 1 && _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).isPlayer1()) {\n                alert(\"game is over and player1 are winner\");\n                _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).finish();\n                return [2 /*return*/];\n            }\n            if (data.game_winner == 2 && _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).isPlayer1()) {\n                alert(\"game is over and player2 are winner\");\n                _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).finish();\n                return [2 /*return*/];\n            }\n            return [2 /*return*/];\n        });\n    });\n}\n//正常的移动\nfunction handleSimpleMoveResult(origX, origY, targetX, targetY) {\n    if (_game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getGameState() == _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_MOVABLE_RESULT) {\n        (0,_player__WEBPACK_IMPORTED_MODULE_8__.movingPlayerHandleSimpleMove)(origX, origY, targetX, targetY);\n    }\n    else {\n        (0,_player__WEBPACK_IMPORTED_MODULE_8__.waitingPlayerHandleSimpleMove)(origX, origY, targetX, targetY);\n    }\n}\n//winner\nfunction handleWinMoveResult(origX, origY, targetX, targetY, oppFlagX, oppFlagY) {\n    if (_game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getGameState() == _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_MOVABLE_RESULT) {\n        (0,_player__WEBPACK_IMPORTED_MODULE_8__.movingPlayerHandleWinMove)(origX, origY, targetX, targetY, oppFlagX, oppFlagY);\n    }\n    else {\n        (0,_player__WEBPACK_IMPORTED_MODULE_8__.waitingPlayerHandleWinMove)(origX, origY, targetX, targetY, oppFlagX, oppFlagY);\n    }\n}\n//平局\nfunction handleDrawMoveEvent(origX, origY, targetX, targetY, flagX, flagY, oppFlagX, oppFlagY) {\n    if (_game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getGameState() == _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_MOVABLE_RESULT) {\n        (0,_player__WEBPACK_IMPORTED_MODULE_8__.movingPlayerHandleDrawMove)(origX, origY, targetX, targetY, oppFlagX, oppFlagY);\n    }\n    else {\n        (0,_player__WEBPACK_IMPORTED_MODULE_8__.waitingPlayerHandleDrawMove)(origX, origY, targetX, targetY, flagX, flagY);\n    }\n}\nfunction handleLoseMoveEvent(origX, origY, flagX, flagY, oppFlagX, oppFlagY) {\n    if (_game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).getGameState() == _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_MOVABLE_RESULT) {\n        (0,_player__WEBPACK_IMPORTED_MODULE_8__.movingPlayerHandleLoseMove)(origX, origY, flagX, flagY);\n    }\n    else {\n        (0,_player__WEBPACK_IMPORTED_MODULE_8__.waitingPlayerHandleLoseMove)(origX, origY, oppFlagX, oppFlagY);\n    }\n}\nfunction stepNextMove(state) {\n    if (state == _game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_MOVEABLE) {\n        _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).setGameState(_game__WEBPACK_IMPORTED_MODULE_5__.EGameState.MOVABLE);\n        (0,_draw__WEBPACK_IMPORTED_MODULE_0__.updateShowMessage)(\"please move piece\");\n    }\n    else {\n        clearSelectChess();\n        _game__WEBPACK_IMPORTED_MODULE_5__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_2__.gameId).setGameState(_game__WEBPACK_IMPORTED_MODULE_5__.EGameState.WAITING_MOVEABLE);\n        (0,_draw__WEBPACK_IMPORTED_MODULE_0__.updateShowMessage)(\"opponent move piece\");\n    }\n    (0,_main__WEBPACK_IMPORTED_MODULE_3__.updateDrawArray)();\n}\n\n\n//# sourceURL=webpack://www/./src/event.ts?");

/***/ }),

/***/ "./src/game.ts":
/*!*********************!*\
  !*** ./src/game.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EGameState: () => (/* binding */ EGameState),\n/* harmony export */   Game: () => (/* binding */ Game)\n/* harmony export */ });\n/* harmony import */ var _login__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./login */ \"./src/login.ts\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event */ \"./src/event.ts\");\n\n\nvar EGameState;\n(function (EGameState) {\n    EGameState[\"WAITING_READY\"] = \"waiting_ready\";\n    EGameState[\"READY\"] = \"ready\";\n    EGameState[\"WAITING_GAME_START\"] = \"waiting_game_start\";\n    EGameState[\"WAITING_MOVABLE_RESULT\"] = \"waiting_movable_result\";\n    EGameState[\"MOVABLE\"] = \"movable\";\n    EGameState[\"WAITING_MOVEABLE\"] = \"waiting_moveable\";\n})(EGameState || (EGameState = {}));\nvar Game = /** @class */ (function () {\n    function Game(gameId, player1, player2, account, arbiter) {\n        this.gameId = gameId;\n        this.player1 = player1;\n        this.player2 = player2;\n        this.account = account;\n        this.arbiter = arbiter;\n        this.state = EGameState.WAITING_READY;\n    }\n    Game.createInstance = function (gameId, player1, player2, account, arbiter) {\n        var instance = new Game(gameId, player1, player2, account, arbiter);\n        Game.instances[gameId] = instance;\n        return instance;\n    };\n    Game.getInstance = function (gameId) {\n        return Game.instances[gameId];\n    };\n    Game.prototype.getPlayer1 = function () {\n        return this.player1;\n    };\n    Game.prototype.getPlayer2 = function () {\n        return this.player2;\n    };\n    Game.prototype.getCurrentAccount = function () {\n        return this.account;\n    };\n    Game.prototype.getGameState = function () {\n        return this.state;\n    };\n    Game.prototype.setGameState = function (state) {\n        this.state = state;\n    };\n    Game.prototype.getOppAddresses = function () {\n        return this.account.toString() == this.player1 ? this.player2 : this.player1;\n    };\n    Game.prototype.getLocalAddresses = function () {\n        return this.account.toString();\n    };\n    Game.prototype.isPlayer1 = function () {\n        return this.player1 == this.account.toString();\n    };\n    Game.prototype.getArbiter = function () {\n        return this.arbiter;\n    };\n    Game.prototype.finish = function () {\n        this.gameId = \"0\";\n        _login__WEBPACK_IMPORTED_MODULE_0__.ws.close();\n        (0,_event__WEBPACK_IMPORTED_MODULE_1__.clearSelectChess)();\n        (0,_event__WEBPACK_IMPORTED_MODULE_1__.initEventsValue)();\n    };\n    Game.instances = {};\n    return Game;\n}());\n\n\n\n//# sourceURL=webpack://www/./src/game.ts?");

/***/ }),

/***/ "./src/init.ts":
/*!*********************!*\
  !*** ./src/init.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canvas: () => (/* binding */ canvas),\n/* harmony export */   ctx: () => (/* binding */ ctx),\n/* harmony export */   current_player: () => (/* binding */ current_player),\n/* harmony export */   drawBoardInit: () => (/* binding */ drawBoardInit),\n/* harmony export */   draw_pos: () => (/* binding */ draw_pos),\n/* harmony export */   eventInit: () => (/* binding */ eventInit),\n/* harmony export */   init: () => (/* binding */ init),\n/* harmony export */   isChessVisible: () => (/* binding */ isChessVisible),\n/* harmony export */   setDefaultPosition: () => (/* binding */ setDefaultPosition)\n/* harmony export */ });\n/* harmony import */ var _chess__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chess */ \"./src/chess.ts\");\n/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./draw */ \"./src/draw.ts\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event */ \"./src/event.ts\");\n/* harmony import */ var _login__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./login */ \"./src/login.ts\");\n/* harmony import */ var _main__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./main */ \"./src/main.ts\");\n\n\n\n\n\nvar draw_pos = [];\nvar current_player = \"0\";\nfunction init() {\n    var x_arr = [7, 370];\n    draw_pos = [];\n    current_player = \"\";\n    x_arr.forEach(function (offset) {\n        for (var i = 0; i < 6; i++) {\n            draw_pos.push({ x: 7, y: offset });\n            draw_pos.push({ x: 102, y: offset });\n            draw_pos.push({ x: 204, y: offset });\n            draw_pos.push({ x: 307, y: offset });\n            draw_pos.push({ x: 400, y: offset });\n            offset += 48;\n        }\n    });\n}\nfunction setDefaultPosition(address, oppAddress) {\n    var p1 = _event__WEBPACK_IMPORTED_MODULE_2__.board.GetChessList(address, false);\n    //1\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 6).setChess(p1[0]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(1, 6).setChess(p1[1]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 6).setChess(p1[2]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(3, 6).setChess(p1[3]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 6).setChess(p1[4]);\n    //2\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 7).setChess(p1[5]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 7).setChess(p1[6]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 7).setChess(p1[7]);\n    //3\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 8).setChess(p1[8]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(1, 8).setChess(p1[9]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(3, 8).setChess(p1[10]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 8).setChess(p1[11]);\n    //4\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 9).setChess(p1[12]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 9).setChess(p1[13]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 9).setChess(p1[14]);\n    //5\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 10).setChess(p1[15]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(1, 10).setChess(p1[16]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 10).setChess(p1[17]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(3, 10).setChess(p1[18]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 10).setChess(p1[19]);\n    //6\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(0, 11).setChess(p1[20]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(1, 11).setChess(p1[21]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(2, 11).setChess(p1[22]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(3, 11).setChess(p1[24]);\n    _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(4, 11).setChess(p1[23]);\n    for (var y = 0; y < 6; y++) {\n        for (var x = 0; x < 5; x++) {\n            if (((x == 1 || x == 3) && (y == 4 || y == 2)) || (x == 2 && y == 3)) {\n                continue;\n            }\n            _event__WEBPACK_IMPORTED_MODULE_2__.board.getLocationInstance(x, y).setChess(new _chess__WEBPACK_IMPORTED_MODULE_0__.Chess(0, oppAddress));\n        }\n    }\n}\nvar canvas;\nvar ctx;\nfunction eventInit() {\n    canvas = document.getElementById(\"Board\");\n    ctx = canvas.getContext(\"2d\");\n    canvas.addEventListener('mousedown', _event__WEBPACK_IMPORTED_MODULE_2__.canvasDown);\n    canvas.addEventListener('mouseup', _event__WEBPACK_IMPORTED_MODULE_2__.canvasUp);\n    canvas.addEventListener('mouseleave', _event__WEBPACK_IMPORTED_MODULE_2__.canvasUp);\n    canvas.addEventListener('mousemove', _event__WEBPACK_IMPORTED_MODULE_2__.canvasMousemove);\n    var startButton = document.getElementById(\"start_button\");\n    startButton.addEventListener(\"click\", _main__WEBPACK_IMPORTED_MODULE_4__.GameReady);\n    var stopButton = document.getElementById(\"stop_button\");\n    stopButton.addEventListener(\"click\", _main__WEBPACK_IMPORTED_MODULE_4__.GameStop);\n    // setInterval(myTimer, 1000);\n    var login = document.getElementById(\"login_button\");\n    login.addEventListener(\"click\", _login__WEBPACK_IMPORTED_MODULE_3__.LoginHandler);\n}\nfunction drawBoardInit(address, oppAddress) {\n    (0,_draw__WEBPACK_IMPORTED_MODULE_1__.resetChess)();\n    init();\n    (0,_draw__WEBPACK_IMPORTED_MODULE_1__.initDraw)();\n    setDefaultPosition(address, oppAddress);\n    (0,_event__WEBPACK_IMPORTED_MODULE_2__.initEventsValue)();\n    setInterval(function () { (0,_draw__WEBPACK_IMPORTED_MODULE_1__.draw)(ctx); });\n    (0,_main__WEBPACK_IMPORTED_MODULE_4__.updateDrawArray)();\n    (0,_draw__WEBPACK_IMPORTED_MODULE_1__.draw)(ctx);\n}\nfunction isChessVisible(chess) {\n    if (chess.displayed == true)\n        return true;\n    if (chess.address == current_player)\n        return true;\n    else\n        return false;\n}\neventInit();\n\n\n//# sourceURL=webpack://www/./src/init.ts?");

/***/ }),

/***/ "./src/location.ts":
/*!*************************!*\
  !*** ./src/location.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   LocationType: () => (/* binding */ LocationType),\n/* harmony export */   LocationType_ZN: () => (/* binding */ LocationType_ZN),\n/* harmony export */   getRevertLocation: () => (/* binding */ getRevertLocation)\n/* harmony export */ });\nvar LocationType_ZN;\n(function (LocationType_ZN) {\n    LocationType_ZN[\"SoldierStation\"] = \"\\u5175\\u8425\";\n    LocationType_ZN[\"Camp\"] = \"\\u884C\\u8425\";\n    LocationType_ZN[\"Headquarters\"] = \"\\u5927\\u672C\\u8425\";\n})(LocationType_ZN || (LocationType_ZN = {}));\n;\nvar LocationType;\n(function (LocationType) {\n    LocationType[\"SoldierStation\"] = \"Soldier Station\";\n    LocationType[\"Camp\"] = \"Camp\";\n    LocationType[\"Headquarters\"] = \"Headquarters\";\n})(LocationType || (LocationType = {}));\n// Represent a movable location on the board\nvar Location = /** @class */ (function () {\n    function Location(x, y, locationType, isOnRail) {\n        this.edges = [];\n        this.isOnRail = false;\n        this.locationType = LocationType.SoldierStation;\n        this.x = x;\n        this.y = y;\n        this.isOnRail = isOnRail;\n        this.locationType = locationType;\n    }\n    // edge is the connection between the locations\n    Location.prototype.addEdge = function (linkedLocation) {\n        if (this.edges.indexOf(linkedLocation) == -1) {\n            this.edges.push(linkedLocation);\n        }\n    };\n    Location.prototype.setChess = function (chess) {\n        this.chess = chess;\n    };\n    Location.prototype.removeChess = function () {\n        this.chess = null;\n    };\n    Location.prototype.getChess = function () {\n        return this.chess;\n    };\n    return Location;\n}());\n\n//将对端发来的location转为本期盘的location\nfunction getRevertLocation(x, y) {\n    return [x, 11 - y];\n}\n\n\n//# sourceURL=webpack://www/./src/location.ts?");

/***/ }),

/***/ "./src/login.ts":
/*!**********************!*\
  !*** ./src/login.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LoginHandler: () => (/* binding */ LoginHandler),\n/* harmony export */   account: () => (/* binding */ account),\n/* harmony export */   changeDisplay: () => (/* binding */ changeDisplay),\n/* harmony export */   gameId: () => (/* binding */ gameId),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   ws: () => (/* binding */ ws)\n/* harmony export */ });\n/* harmony import */ var _aleohq_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aleohq/sdk */ \"./aleo/sdk/src/index.js\");\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./api */ \"./src/api.ts\");\n/* harmony import */ var _websocket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket */ \"./src/websocket.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\nvar ws;\nvar account;\nvar gameId = \"0\";\nfunction sleep(ms) {\n    return new Promise(function (resolve) { return setTimeout(resolve, ms); });\n}\nfunction getGameIdFromServer() {\n    return __awaiter(this, void 0, void 0, function () {\n        var roomCodeInput, privateKeyInput, loading, roomCode, privateKey, i, tryCnt;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    roomCodeInput = document.getElementById(\"room_code\");\n                    privateKeyInput = document.getElementById(\"private_key\");\n                    loading = document.getElementById(\"loading\");\n                    loading.style.display = \"block\";\n                    roomCode = roomCodeInput.value;\n                    privateKey = privateKeyInput.value;\n                    account = new _aleohq_sdk__WEBPACK_IMPORTED_MODULE_0__.Account({ privateKey: privateKey });\n                    console.log('account address:', account.toString());\n                    return [4 /*yield*/, (0,_api__WEBPACK_IMPORTED_MODULE_1__.getGameId)(account.toString(), roomCode)];\n                case 1:\n                    gameId = _a.sent();\n                    if (gameId != \"0\") {\n                        loading.style.display = \"none\";\n                        return [2 /*return*/, gameId];\n                    }\n                    i = 0, tryCnt = 20;\n                    _a.label = 2;\n                case 2:\n                    if (!(i < tryCnt)) return [3 /*break*/, 6];\n                    return [4 /*yield*/, (0,_api__WEBPACK_IMPORTED_MODULE_1__.pollGetGameId)(account.toString())];\n                case 3:\n                    gameId = _a.sent();\n                    if (gameId != \"0\") {\n                        return [3 /*break*/, 6];\n                    }\n                    return [4 /*yield*/, sleep(2000)];\n                case 4:\n                    _a.sent();\n                    _a.label = 5;\n                case 5:\n                    i++;\n                    return [3 /*break*/, 2];\n                case 6:\n                    console.log('getGameIdFromServer:', gameId);\n                    // 隐藏加载动画\n                    loading.style.display = \"none\";\n                    return [2 /*return*/, gameId];\n            }\n        });\n    });\n}\nfunction connectWs(gameId, address) {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    // 使用示例\n                    ws = new _websocket__WEBPACK_IMPORTED_MODULE_2__.WebSocketClient(\"ws://127.0.0.1:3000/game?game_id=\".concat(gameId, \"&player=\").concat(address));\n                    ws.setMessageCallback(_websocket__WEBPACK_IMPORTED_MODULE_2__.handleWsServerMsg);\n                    return [4 /*yield*/, ws.connect()];\n                case 1:\n                    _a.sent();\n                    console.log(\"connect ws:\", JSON.stringify(ws));\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction changeDisplay() {\n    // 隐藏登录框\n    var loginContainer = document.getElementById('login-container');\n    loginContainer.style.display = 'none';\n    // 显示棋盘\n    var chessboardContainer = document.getElementById('board_container');\n    chessboardContainer.style.display = 'block';\n}\nfunction LoginHandler() {\n    return __awaiter(this, void 0, void 0, function () {\n        var gameId;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    console.log(\"enter LoginHandler\");\n                    return [4 /*yield*/, getGameIdFromServer()];\n                case 1:\n                    gameId = _a.sent();\n                    if (gameId == \"0\") {\n                        alert(\"未到匹配的玩家，等稍后重试!\");\n                        return [2 /*return*/];\n                    }\n                    console.log(\"enter connectWs\");\n                    return [4 /*yield*/, connectWs(gameId, account.toString())];\n                case 2:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n\n\n//# sourceURL=webpack://www/./src/login.ts?");

/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHESS_HEIGHT: () => (/* binding */ CHESS_HEIGHT),\n/* harmony export */   CHESS_WIDTH: () => (/* binding */ CHESS_WIDTH),\n/* harmony export */   GameReady: () => (/* binding */ GameReady),\n/* harmony export */   GameStop: () => (/* binding */ GameStop),\n/* harmony export */   bgColors: () => (/* binding */ bgColors),\n/* harmony export */   chess_changed: () => (/* binding */ chess_changed),\n/* harmony export */   gameStarted: () => (/* binding */ gameStarted),\n/* harmony export */   player_color: () => (/* binding */ player_color),\n/* harmony export */   timer_value: () => (/* binding */ timer_value),\n/* harmony export */   updateDrawArray: () => (/* binding */ updateDrawArray)\n/* harmony export */ });\n/* harmony import */ var _chess__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chess */ \"./src/chess.ts\");\n/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./draw */ \"./src/draw.ts\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./event */ \"./src/event.ts\");\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./game */ \"./src/game.ts\");\n/* harmony import */ var _login__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./login */ \"./src/login.ts\");\n/* harmony import */ var _aleo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./aleo */ \"./src/aleo.ts\");\n/* harmony import */ var _aleo_wasm_pkg_aleo_wasm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../aleo/wasm/pkg/aleo_wasm */ \"./aleo/wasm/pkg/aleo_wasm.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\n\n\n\n\n(0,_aleo_wasm_pkg_aleo_wasm__WEBPACK_IMPORTED_MODULE_6__[\"default\"])().then(function (wasm) { return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n        (0,_aleo__WEBPACK_IMPORTED_MODULE_5__.newAleoClient)(_aleo__WEBPACK_IMPORTED_MODULE_5__.aleoUrl);\n        return [2 /*return*/];\n    });\n}); });\nvar CHESS_WIDTH = 60;\nvar CHESS_HEIGHT = 33;\n// export const player_color = [\"red\",\"blue\"]\nvar player_color = [\"#FFFFFF\", \"#FFFFFF\"];\nvar bgColors = [\"#E74C3C\", \"#3498DB\"];\n//timer\nvar timer_value = 0;\nvar gameStarted = false;\nvar chess_changed = true;\n// export function myTimer(): void {\n//   if (gameStarted) {\n//     const timerElement = document.getElementById(\"timer\") as HTMLInputElement;\n//     let i = parseInt(timerElement.value);\n//     if (i > 0) {\n//       timerElement.value = (i - 1).toString();\n//     } else {\n//       alert(\"Time's up!\");\n//       gameStarted = false;\n//     }\n//   }\n// }\n// export function timerNextPlayer(): void {\n//   const timerElement = document.getElementById(\"timer\") as HTMLInputElement;\n//   timerElement.value = timer_value.toString();\n// }\nfunction GameReady() {\n    // const timerElement = document.getElementById(\"timer\") as HTMLInputElement;\n    // timer_value = parseInt(timerElement.value);\n    // timerElement.disabled = true;\n    var startButton = document.getElementById(\"start_button\");\n    startButton.style.visibility = \"hidden\";\n    var stopButton = document.getElementById(\"stop_button\");\n    stopButton.style.visibility = \"visible\";\n    console.log(\"GameReady\");\n    (0,_aleo__WEBPACK_IMPORTED_MODULE_5__.aleoInitializeBoard)().then(function () {\n        _login__WEBPACK_IMPORTED_MODULE_4__.ws.sendReadyEvent(_login__WEBPACK_IMPORTED_MODULE_4__.gameId).then();\n        (0,_event__WEBPACK_IMPORTED_MODULE_2__.clearSelectChess)();\n        _game__WEBPACK_IMPORTED_MODULE_3__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_4__.gameId).setGameState(_game__WEBPACK_IMPORTED_MODULE_3__.EGameState.WAITING_GAME_START);\n    });\n}\nfunction GameStop() {\n    // const timerElement = document.getElementById(\"timer\") as HTMLInputElement;\n    // timerElement.disabled = false;\n    var startButton = document.getElementById(\"start_button\");\n    startButton.style.visibility = \"visible\";\n    var stopButton = document.getElementById(\"stop_button\");\n    stopButton.style.visibility = \"hidden\";\n    gameStarted = false;\n}\nfunction isChessVisible(chess) {\n    if (chess.displayed == true || chess.address == _login__WEBPACK_IMPORTED_MODULE_4__.account.toString()) {\n        return true;\n    }\n    return false;\n}\nfunction getPlayerIndex(address) {\n    var player1 = _game__WEBPACK_IMPORTED_MODULE_3__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_4__.gameId).getPlayer1();\n    return (address == player1) ? 0 : 1;\n}\nfunction getPlayerColor(playerIndex) {\n    return player_color[playerIndex];\n}\nfunction getBgColor(playerIndex) {\n    return bgColors[playerIndex];\n}\nfunction updateDrawArray() {\n    (0,_draw__WEBPACK_IMPORTED_MODULE_1__.resetChess)();\n    for (var _i = 0, _a = _event__WEBPACK_IMPORTED_MODULE_2__.board.locations; _i < _a.length; _i++) {\n        var location_1 = _a[_i];\n        var chess = location_1.getChess();\n        if (chess && chess.chessStatus == _chess__WEBPACK_IMPORTED_MODULE_0__.ChessStatus.OnBoard) {\n            var visible = isChessVisible(chess);\n            var playerIndex = getPlayerIndex(chess.address);\n            var color = getPlayerColor(playerIndex);\n            var rank = _chess__WEBPACK_IMPORTED_MODULE_0__.RANK_ZH[chess.rank];\n            (0,_draw__WEBPACK_IMPORTED_MODULE_1__.drawChess)(rank, location_1.x, location_1.y, color, visible, getBgColor(playerIndex));\n        }\n    }\n}\n\n\n//# sourceURL=webpack://www/./src/main.ts?");

/***/ }),

/***/ "./src/player.ts":
/*!***********************!*\
  !*** ./src/player.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   movingPlayerHandleDrawMove: () => (/* binding */ movingPlayerHandleDrawMove),\n/* harmony export */   movingPlayerHandleLoseMove: () => (/* binding */ movingPlayerHandleLoseMove),\n/* harmony export */   movingPlayerHandleSimpleMove: () => (/* binding */ movingPlayerHandleSimpleMove),\n/* harmony export */   movingPlayerHandleWinMove: () => (/* binding */ movingPlayerHandleWinMove),\n/* harmony export */   updateChessDrawMove: () => (/* binding */ updateChessDrawMove),\n/* harmony export */   waitingPlayerHandleDrawMove: () => (/* binding */ waitingPlayerHandleDrawMove),\n/* harmony export */   waitingPlayerHandleLoseMove: () => (/* binding */ waitingPlayerHandleLoseMove),\n/* harmony export */   waitingPlayerHandleSimpleMove: () => (/* binding */ waitingPlayerHandleSimpleMove),\n/* harmony export */   waitingPlayerHandleWinMove: () => (/* binding */ waitingPlayerHandleWinMove)\n/* harmony export */ });\n/* harmony import */ var _chess__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chess */ \"./src/chess.ts\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event */ \"./src/event.ts\");\n/* harmony import */ var _game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./game */ \"./src/game.ts\");\n/* harmony import */ var _location__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./location */ \"./src/location.ts\");\n/* harmony import */ var _login__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./login */ \"./src/login.ts\");\n\n\n\n\n\nfunction revealOppFlag(oppFlagX, oppFlagY) {\n    var _a = (0,_location__WEBPACK_IMPORTED_MODULE_3__.getRevertLocation)(oppFlagX, oppFlagY), revertFlagX = _a[0], revertFlagY = _a[1];\n    var flagLocation = _event__WEBPACK_IMPORTED_MODULE_1__.board.getLocationInstance(revertFlagX, revertFlagY);\n    var flagChess = new _chess__WEBPACK_IMPORTED_MODULE_0__.Chess(_chess__WEBPACK_IMPORTED_MODULE_0__.Rank.Flag, _game__WEBPACK_IMPORTED_MODULE_2__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_4__.gameId).getOppAddresses());\n    flagChess.displayed = true;\n    flagLocation.setChess(flagChess);\n}\n//走棋方 处理simpl move\nfunction movingPlayerHandleSimpleMove(oriX, oriY, targetX, targetY) {\n    var oriLocation = _event__WEBPACK_IMPORTED_MODULE_1__.board.getLocationInstance(oriX, oriY);\n    var chess = oriLocation.getChess();\n    oriLocation.removeChess();\n    var targetLocation = _event__WEBPACK_IMPORTED_MODULE_1__.board.getLocationInstance(targetX, targetY);\n    targetLocation.setChess(chess);\n}\n//待走棋方 x、y已经坐标已经转换\nfunction waitingPlayerHandleSimpleMove(oriX, oriY, targetX, targetY) {\n    console.log(\"waitingPlayerHandleSimpleMove\");\n    var oriLocation = _event__WEBPACK_IMPORTED_MODULE_1__.board.getLocationInstance(oriX, oriY);\n    var chess = oriLocation.getChess();\n    oriLocation.removeChess();\n    var targetLocation = _event__WEBPACK_IMPORTED_MODULE_1__.board.getLocationInstance(targetX, targetY);\n    targetLocation.setChess(chess);\n}\nfunction updateChessWinMove(origX, origY, targetX, targetY) {\n    var targetLocation = _event__WEBPACK_IMPORTED_MODULE_1__.board.getLocationInstance(targetX, targetY);\n    var oriLocation = _event__WEBPACK_IMPORTED_MODULE_1__.board.getLocationInstance(origX, origY);\n    var chess = oriLocation.getChess();\n    var targetChess = targetLocation.getChess();\n    oriLocation.removeChess();\n    _event__WEBPACK_IMPORTED_MODULE_1__.board.destroy_chess(targetChess);\n    targetLocation.setChess(chess);\n}\n//走棋方处理\nfunction movingPlayerHandleWinMove(origX, origY, targetX, targetY, oppFlagX, oppFlagY) {\n    console.log(\"movingPlayerHandleWinMove\");\n    updateChessWinMove(origX, origY, targetX, targetY);\n    if (_event__WEBPACK_IMPORTED_MODULE_1__.board.isFlagLocation(oppFlagX, oppFlagY)) {\n        revealOppFlag(oppFlagX, oppFlagY);\n    }\n}\n//待走期方处理\nfunction waitingPlayerHandleWinMove(origX, origY, targetX, targetY, oppFlagX, oppFlagY) {\n    console.log(\"waitingPlayerHandleWinMove\");\n    updateChessWinMove(origX, origY, targetX, targetY);\n    //对方赢了,本方暴露军旗\n    if (_event__WEBPACK_IMPORTED_MODULE_1__.board.isFlagLocation(oppFlagX, oppFlagY)) {\n        _event__WEBPACK_IMPORTED_MODULE_1__.board.RevealFlag(_game__WEBPACK_IMPORTED_MODULE_2__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_4__.gameId).getLocalAddresses());\n    }\n}\nfunction updateChessDrawMove(origX, origY, targetX, targetY) {\n    console.log(\"updateChessDrawMove orig(\".concat(origX, \",\").concat(origY, \") target:(\").concat(targetX, \",\").concat(targetY, \")\"));\n    var oriLocation = _event__WEBPACK_IMPORTED_MODULE_1__.board.getLocationInstance(origX, origY);\n    var chess = oriLocation.getChess();\n    oriLocation.removeChess();\n    var targetLocation = _event__WEBPACK_IMPORTED_MODULE_1__.board.getLocationInstance(targetX, targetY);\n    var targetChess = targetLocation.getChess();\n    targetLocation.removeChess();\n    _event__WEBPACK_IMPORTED_MODULE_1__.board.destroy_chess(chess);\n    _event__WEBPACK_IMPORTED_MODULE_1__.board.destroy_chess(targetChess);\n}\n//走棋方处理draw事件\nfunction movingPlayerHandleDrawMove(origX, origY, targetX, targetY, oppFlagX, oppFlagY) {\n    console.log(\"movingPlayerHandleDrawMove\");\n    updateChessDrawMove(origX, origY, targetX, targetY);\n    //对方40挂了，才会有flag\n    if (_event__WEBPACK_IMPORTED_MODULE_1__.board.isFlagLocation(oppFlagX, oppFlagY)) {\n        revealOppFlag(oppFlagX, oppFlagY);\n    }\n}\n//待走棋方处理draw事件\nfunction waitingPlayerHandleDrawMove(origX, origY, targetX, targetY, flagX, flagY) {\n    console.log(\"waitingPlayerHandleDrawMove\");\n    updateChessDrawMove(origX, origY, targetX, targetY);\n    //显示走棋方军旗\n    if (_event__WEBPACK_IMPORTED_MODULE_1__.board.isFlagLocation(flagX, flagY)) {\n        revealOppFlag(flagX, flagY);\n    }\n}\nfunction movingPlayerHandleLoseMove(origX, origY, flagX, flagY) {\n    console.log(\"movingPlayerHandleLoseMove\");\n    var oriLocation = _event__WEBPACK_IMPORTED_MODULE_1__.board.getLocationInstance(origX, origY);\n    var chess = oriLocation.getChess();\n    oriLocation.removeChess();\n    _event__WEBPACK_IMPORTED_MODULE_1__.board.destroy_chess(chess);\n    //我方需要display军旗\n    if (_event__WEBPACK_IMPORTED_MODULE_1__.board.isFlagLocation(flagX, flagY)) {\n        _event__WEBPACK_IMPORTED_MODULE_1__.board.RevealFlag(_game__WEBPACK_IMPORTED_MODULE_2__.Game.getInstance(_login__WEBPACK_IMPORTED_MODULE_4__.gameId).getLocalAddresses());\n    }\n}\nfunction waitingPlayerHandleLoseMove(origX, origY, oppFlagX, oppFlagY) {\n    console.log(\"waitingPlayerHandleLoseMove\");\n    var oriLocation = _event__WEBPACK_IMPORTED_MODULE_1__.board.getLocationInstance(origX, origY);\n    var chess = oriLocation.getChess();\n    oriLocation.removeChess();\n    _event__WEBPACK_IMPORTED_MODULE_1__.board.destroy_chess(chess);\n    //需要display对方军旗\n    if (_event__WEBPACK_IMPORTED_MODULE_1__.board.isFlagLocation(oppFlagX, oppFlagY)) {\n        revealOppFlag(oppFlagX, oppFlagY);\n    }\n}\n\n\n//# sourceURL=webpack://www/./src/player.ts?");

/***/ }),

/***/ "./src/websocket.ts":
/*!**************************!*\
  !*** ./src/websocket.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketClient: () => (/* binding */ WebSocketClient),\n/* harmony export */   handleWsServerMsg: () => (/* binding */ handleWsServerMsg)\n/* harmony export */ });\n/* harmony import */ var _chess__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chess */ \"./src/chess.ts\");\n/* harmony import */ var _event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event */ \"./src/event.ts\");\n/* harmony import */ var _login__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./login */ \"./src/login.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n\n\n\nvar WebSocketClient = /** @class */ (function () {\n    function WebSocketClient(url) {\n        this.url = url;\n        this.socket = null;\n        this.messageCallback = null;\n    }\n    WebSocketClient.prototype.connect = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.socket = new WebSocket(_this.url);\n            _this.socket.onopen = function () {\n                console.log('WebSocket connection established');\n                resolve();\n            };\n            _this.socket.onclose = _this.onClose.bind(_this);\n            _this.socket.onmessage = _this.onMessage.bind(_this);\n            _this.socket.onerror = _this.onError.bind(_this);\n            _this.setMessageCallback(handleWsServerMsg);\n        });\n    };\n    WebSocketClient.prototype.onClose = function (event) {\n        console.log('WebSocket connection closed');\n    };\n    WebSocketClient.prototype.onMessage = function (event) {\n        var message = event.data;\n        console.log('Received message:', message);\n        if (this.messageCallback) {\n            this.messageCallback(message);\n        }\n    };\n    WebSocketClient.prototype.onError = function (event) {\n        console.error('WebSocket error:', event);\n    };\n    WebSocketClient.prototype.sendAsync = function (message) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            if (_this.socket && _this.socket.readyState === WebSocket.OPEN) {\n                _this.socket.send(message);\n                resolve();\n            }\n            else {\n                _this.setMessageCallback(function () {\n                    var _a;\n                    (_a = _this.socket) === null || _a === void 0 ? void 0 : _a.send(message);\n                    resolve();\n                });\n            }\n        });\n    };\n    WebSocketClient.prototype.close = function () {\n        if (this.socket) {\n            this.socket.close();\n        }\n    };\n    WebSocketClient.prototype.setMessageCallback = function (callback) {\n        this.messageCallback = callback;\n    };\n    WebSocketClient.prototype.sendReadyEvent = function (gameId) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        console.log(\"send message to server\", gameId);\n                        return [4 /*yield*/, _login__WEBPACK_IMPORTED_MODULE_2__.ws.sendAsync(JSON.stringify({ type: \"ready\", game_id: gameId }))];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    WebSocketClient.prototype.sendMoveEvent = function (piece, x, y, targetX, targetY, flagX, flagY) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        console.log(\"send move event to server piece rank:\".concat(piece, \" (x:\").concat(x, \",y:\").concat(y, \") (targetX:\").concat(targetX, \" targetY:\").concat(targetY, \")\"));\n                        if (!(piece == _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.FieldMarshal)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, _login__WEBPACK_IMPORTED_MODULE_2__.ws.sendAsync(JSON.stringify({ type: \"move\", piece: piece, x: x, y: y,\n                                target_x: targetX, target_y: targetY, flag_x: flagX, flag_y: flagY }))];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 4];\n                    case 2: return [4 /*yield*/, _login__WEBPACK_IMPORTED_MODULE_2__.ws.sendAsync(JSON.stringify({ type: \"move\", piece: piece, x: x, y: y, target_x: targetX, target_y: targetY }))];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    WebSocketClient.prototype.sendWhisperEvent = function (piece, x, y, flagX, flagY) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        console.log(\"sendWhisperEvent rank:\".concat(piece, \" (x:\").concat(x, \",y:\").concat(y, \" flag(\").concat(flagX, \",\").concat(flagY, \"))\"));\n                        if (!(piece == _chess__WEBPACK_IMPORTED_MODULE_0__.Rank.FieldMarshal)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, _login__WEBPACK_IMPORTED_MODULE_2__.ws.sendAsync(JSON.stringify({ type: \"whisper\", piece: piece, x: x, y: y, flag_x: flagX, flag_y: flagY }))];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 4];\n                    case 2: return [4 /*yield*/, _login__WEBPACK_IMPORTED_MODULE_2__.ws.sendAsync(JSON.stringify({ type: \"whisper\", piece: piece, x: x, y: y }))];\n                    case 3:\n                        _a.sent();\n                        _a.label = 4;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return WebSocketClient;\n}());\n\nvar EMessageType;\n(function (EMessageType) {\n    EMessageType[\"ROLE\"] = \"role\";\n    EMessageType[\"READY\"] = \"ready\";\n    EMessageType[\"GAME_START\"] = \"gameStart\";\n    EMessageType[\"MOVE\"] = \"move\";\n    EMessageType[\"PIECE_POS\"] = \"piecePos\";\n    EMessageType[\"MOVE_RESULT\"] = \"moveResult\";\n})(EMessageType || (EMessageType = {}));\nfunction handleWsServerMsg(message) {\n    var _a;\n    var jsData = JSON.parse(message);\n    var handlers = (_a = {},\n        _a[EMessageType.ROLE] = _event__WEBPACK_IMPORTED_MODULE_1__.handleRole,\n        _a[EMessageType.GAME_START] = _event__WEBPACK_IMPORTED_MODULE_1__.handleGameStart,\n        _a[EMessageType.PIECE_POS] = _event__WEBPACK_IMPORTED_MODULE_1__.handlePiecePosEvent,\n        _a[EMessageType.MOVE_RESULT] = _event__WEBPACK_IMPORTED_MODULE_1__.handleMoveResult,\n        _a);\n    var handler = handlers[jsData.type];\n    if (handler) {\n        handler(jsData);\n    }\n    else {\n        console.log(\"Unknown message type:\", jsData.type);\n    }\n}\n\n\n//# sourceURL=webpack://www/./src/websocket.ts?");

/***/ }),

/***/ "./aleo/wasm/pkg/aleo_wasm_bg.wasm":
/*!*****************************************!*\
  !*** ./aleo/wasm/pkg/aleo_wasm_bg.wasm ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"5b356a70c52d4ec51915.wasm\";\n\n//# sourceURL=webpack://www/./aleo/wasm/pkg/aleo_wasm_bg.wasm?");

/***/ })

}]);